## sigstore
One of the main values of sigstore is to sign/validate/verify artifacts, like
thirdparty software dependencies, to avoid supply chain attacks. It has not been
very easy to sign code/modules/containers etc before which has led to people
simply not doing it. It is the software and also the maintaince of keys which
adds makes this difficult.

sigstore is a project under the CNFC and it goal is to provide a
software-signing equivalent to `Let's Encrypt`. It is not just one tool but a
collection of tools namely; `fulico`, `rekor`, and `cosign`. 

With sigstore we don't have to manage private keys, and it makes it simpler to
handle revocation.

### Installation
```console
$ go install github.com/sigstore/cosign/cmd/cosign@latest
```

### Fulcio
Is a root CA for code signing certs, and issues code-signing certificates.
Importantly it is an automatic certificate authority.

The certificates that Fulicio provides are not like the ones we use for TLS but
they are intended for code signing. The `KeyUsage` field looks like this:
```
X509v3 Key Usage: critical
    Digital Signature
X509v3 Extended Key Usage:
    Code Signing
```
For the meaning of critical see [certificates.md](./certificates.md).

The `Subject` field is also different. This is typically a domain name in a TLS
certificate but in a code-signing certificate these are email addresses (people)
or SPIFFE SVID (workloads).

Fulcio has to validate the user/system that is requesting a certificate to be
created for it. OpenID Connect (OIDC) can be used so it will handle the email
address, Fulcio signs X.509 certificates valid for 10 minutes.

Every certificate issued will be appended to a public certificate transparency
(CT) log. This log can be inspected by anyone and the certificates can be used
to verify signatures. This is not the Rekor log.

So Fulcio will first create a special x.509 extension called a poision extension
in the certifiate before it is added to the CT log. This kind of cert is called
a precertifcate and is not useful by clients at this stage.
The response from the CT is a signed certificate timestamp (SCT) which is a
promise of inclusion in the CT log.
Now, this SCT is embedded into the certificate and it is signed again to include
this information in the signature. Then the certificate is returned to the
client.


## Rekor
Is the transparency log which is immutable, append only log which can be used
other parties to check what was signed and by whom. It can hold signed metadata
generated by a software projects supply chain. 

It has a restful API server, https://rekor.sigstore.dev.
Example of retrieving a log entry can be done using:
```
$ curl -s https://rekor.sigstore.dev/api/v1/log/entries?logIndex=3321511 | jq
```

Installing `rekor-cli`:
```console
$ go install -v github.com/sigstore/rekor/cmd/rekor-cli@latest
```

### cosign
Is a signing tool which I think is named after container signing but it can be
used to sign anything blob of data.

Signing steps:
* A keypair for codesigning is generated.
* The user authenticates to an OpenID Connect Provider (OIDC) to verify the ownership of their email address.
* Upon successful authentication a code-signing cert is received.
* The code-signing cert is published to Rekor, the transparency log.
* User signs an artifact using the certificatate and the private key from the keypair.
* The signature from the signed artifact is published to Rekor.
* The keypair used are deleted
* The signed artifact can be published.

#### Blob signing
Even though cosign "has container in its name" it can be used to store other
types of files. We can store any blob we like using `cosign upload blob`:

First create a file that we want to upload:
```console
$ echo "bajja" > artifact
```
Next, we can hash this file using:
```console
$ shasum -a 256 artifact
311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95 artifact
```
Create a unique name for the file to be uploaded:
```console
$ uuidgen | head -c 8
c408de42
```
We can take that and c408de42 and use it in a name to make our artifact name
unique:
```
test-blob-upload-c408de42
```
Now, upload the blob using cosign to [ttl.sh](https://ttl.sh/):
```console
$ cosign upload blob -f artifact ttl.sh/test-blob-upload-c408de42:1h
Uploading file from [artifact] to [ttl.sh/test-blob-upload-c408de42:1h] with media type [text/plain]
File [artifact] is available directly at [ttl.sh/v2/test-blob-upload-c408de42/blobs/sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95]

Uploaded image to:
ttl.sh/test-blob-upload-c408de42@sha256:2d7b03e920733c17a89742a965be0fda49270b9b95f4dc2e3efe60fb8579b2c5
```
Fetch the file:
```console
$ curl -L ttl.sh/v2/test-blob-upload-c408de42/blobs/sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95 > fetched-artifact
```

```console
$ cat fetched-artifact | shasum -a 256
311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95  -
```
Sign...
```console
$ cosign sign --key cosign.key ttl.sh/test-blob-upload-c408de42@sha256:2d7b03e920733c17a89742a965be0fda49270b9b95f4dc2e3efe60fb8579b2c5
Enter password for private key: 
Pushing signature to: ttl.sh/test-blob-upload-c408de42
```
```console
$ cosign verify --key cosign.pub ttl.sh/v2/test-blob-upload-c408de42/blobs/sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95
```




#### keyless signatures
These are when shortlived keys are used.
```console
$ COSIGN_EXPERIMENTAL=1 cosign sign $IMAGE_DIGEST
```

#### Trust Root
To verify the identity of a system we need to ask that system to present us
with credentials. And we then need to verify those credentials. To do this we
need to have something at the beginning of this flow that we trust can verify
these credentials. In WebPKI there are Root Certificate Authorities (CA) which
are built into browsers and OS's. A browser will check that a website has the
identity it claims by checking that it can be chained back to one of these
Root CA's.
In sigstores case the root trust allows users and systems to automatically
retreive digital certificates that prove who they are, and they use these
certs to sign artifacts that they produce and distribute. The users of these
artifacts can verify the signatures and certificates against the trust root.

### OpenID Connect
This is used for authentication.

### Signing JavaScript
First we have to install https://github.com/sigstore/sigstore-js and npm link
it:
```console
$ git clone https://github.com/sigstore/sigstore-js
$ npm i && npm r build
$ npm link
```


Next we have to generate the artifact to be signed:
```console
$ cd sigstore/npm-example
$ npm link sigstore
$ npm pack
```
This will generate a file named something like `npm-example-1.0.0.tgz`.
We can now sign this artifact using `sigstore`:
```console
$ which sigstore 
~/.nvm/versions/node/v18.4.0/bin/sigstore

$ sigstore sign ./npm-example-1.0.0.tgz > signature
Your browser will now be opened to: https://oauth2.sigstore.dev/auth/auth?response_type=code&client_id=sigstore&client_secret=&scope=openid+email&redirect_uri=http%3A%2F%2Flocalhost%3A45341&code_challenge=uL8NRr4KXZqeF3R5oi6YxBB17frl7WwjE6fengMrLuA&code_challenge_method=S256&state=lhufn6GM15TjGVmaxlIc2w&nonce=DOCLvVWN2UHTm6izNFaoLA
Created entry at index 4874058, available at
https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058
```
The above command will open a browser and ask for the Sigstore OAuth page. I
used GitHub as the identity provider to be used.

We can now inspect the generated `signature` file that was the output of the
above command:
```console
$ cat signature | jq
{
  "attestationType": "attestation/blob",
  "attestation": {
    "payloadHash": "4f2fb5c9d049ebad8d3d25f55ffdf49b290f7f84f56b89fe3d6663b48b856ad1",
    "payloadHashAlgorithm": "sha256",
    "signature": "MEYCIQDPnJgOdxFnx4Sb6XZRBnnThGfTGGFBgA6ZnQ/YE15GygIhAI9mlq+gAvSfSv/ilA0l90ogR2HSxntOQrd8FIsKMrS5"
  },
  "certificate": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNwekNDQWk2Z0F3SUJBZ0lVYlltS0wranVScVRjV2Y5bjRCdnErMUZnM3kwd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJd09ESTVNRGt3TURNeFdoY05Nakl3T0RJNU1Ea3hNRE14V2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVNWWtwT0NibFRIUURxT2tqeDNwRFo1QnRIZkZPRlFCeittcnkKeGpseDRyb2xpTU0vVGd6ZlVoUkhrSE9BUTJDL2NHZzRwSGRVeWRib0lnMGZzK2RSMTZPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVU5bXlHCmZOWjErRzNJcysvcnJYaDVMOENabk5zd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdBSVlKTHdLRkwvYUVYUjBXc25oSnhGWnhpc0ZqM0RPTkp0NXJ3aUJqWnYKY2dBQUFZTG8xTHNmQUFBRUF3QkhNRVVDSVFENktGd1dOcE0yNS8ySDFCVExsZnhXU3owVDBFS0g5cGZFRVFkTQpQdEQ2OVFJZ1hLZnR0OXhQNjdBaUJKOHhlY3kwOFpHZUlwdzJubkl1M083K1B0WDZObUV3Q2dZSUtvWkl6ajBFCkF3TURad0F3WkFJd0VFM3NWVFhXNFBWeWZtMGx6dlZnVG1pclNMSzJzZmRtdzdrTmhKVVY5YjNTTVJ3N250UDgKVElJNDZSWHBIVHJWQWpCbTZCVGg2MTNHZVBzeXdHNUtDMkwyVjBRZS8wK2p0MkJuQjQ4M3JwTW5XcnVoaVNxYwpBVnR1UU95SlBWSko0anc9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNHakNDQWFHZ0F3SUJBZ0lVQUxuVmlWZm5VMGJySmFzbVJrSHJuL1VuZmFRd0NnWUlLb1pJemowRUF3TXcKS2pFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUkV3RHdZRFZRUURFd2h6YVdkemRHOXlaVEFlRncweQpNakEwTVRNeU1EQTJNVFZhRncwek1URXdNRFV4TXpVMk5UaGFNRGN4RlRBVEJnTlZCQW9UREhOcFozTjBiM0psCkxtUmxkakVlTUJ3R0ExVUVBeE1WYzJsbmMzUnZjbVV0YVc1MFpYSnRaV1JwWVhSbE1IWXdFQVlIS29aSXpqMEMKQVFZRks0RUVBQ0lEWWdBRThSVlMveXNIK05PdnVEWnlQSVp0aWxnVUY5TmxhcllwQWQ5SFAxdkJCSDFVNUNWNwo3TFNTN3MwWmlING5FN0h2N3B0UzZMdnZSL1NUazc5OExWZ016TGxKNEhlSWZGM3RIU2FleExjWXBTQVNyMWtTCjBOL1JnQkp6LzlqV0NpWG5vM3N3ZVRBT0JnTlZIUThCQWY4RUJBTUNBUVl3RXdZRFZSMGxCQXd3Q2dZSUt3WUIKQlFVSEF3TXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBREFkQmdOVkhRNEVGZ1FVMzlQcHoxWWtFWmI1cU5qcApLRldpeGk0WVpEOHdId1lEVlIwakJCZ3dGb0FVV01BZVg1RkZwV2FwZXN5UW9aTWkwQ3JGeGZvd0NnWUlLb1pJCnpqMEVBd01EWndBd1pBSXdQQ3NRSzREWWlaWURQSWFEaTVIRktuZnhYeDZBU1NWbUVSZnN5bllCaVgyWDZTSlIKblpVODQvOURaZG5GdnZ4bUFqQk90NlFwQmxjNEovMER4dmtUQ3FwY2x2emlMNkJDQ1BuamRsSUIzUHUzQnhzUApteWdVWTdJaTJ6YmRDZGxpaW93PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlCOXpDQ0FYeWdBd0lCQWdJVUFMWk5BUEZkeEhQd2plRGxvRHd5WUNoQU8vNHdDZ1lJS29aSXpqMEVBd013CktqRVZNQk1HQTFVRUNoTU1jMmxuYzNSdmNtVXVaR1YyTVJFd0R3WURWUVFERXdoemFXZHpkRzl5WlRBZUZ3MHkKTVRFd01EY3hNelUyTlRsYUZ3MHpNVEV3TURVeE16VTJOVGhhTUNveEZUQVRCZ05WQkFvVERITnBaM04wYjNKbApMbVJsZGpFUk1BOEdBMVVFQXhNSWMybG5jM1J2Y21Vd2RqQVFCZ2NxaGtqT1BRSUJCZ1VyZ1FRQUlnTmlBQVQ3ClhlRlQ0cmIzUFFHd1M0SWFqdExrMy9PbG5wZ2FuZ2FCY2xZcHNZQnI1aSs0eW5CMDdjZWIzTFAwT0lPWmR4ZXgKWDY5YzVpVnV5SlJRK0h6MDV5aStVRjN1QldBbEhwaVM1c2gwK0gyR0hFN1NYcmsxRUM1bTFUcjE5TDlnZzkyagpZekJoTUE0R0ExVWREd0VCL3dRRUF3SUJCakFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQjBHQTFVZERnUVdCQlJZCndCNWZrVVdsWnFsNnpKQ2hreUxRS3NYRitqQWZCZ05WSFNNRUdEQVdnQlJZd0I1ZmtVV2xacWw2ekpDaGt5TFEKS3NYRitqQUtCZ2dxaGtqT1BRUURBd05wQURCbUFqRUFqMW5IZVhacCsxM05XQk5hK0VEc0RQOEcxV1dnMXRDTQpXUC9XSFBxcGFWbzBqaHN3ZU5GWmdTczBlRTd3WUk0cUFqRUEyV0I5b3Q5OHNJa29GM3ZaWWRkMy9WdFdCNWI5ClROTWVhN0l4L3N0SjVUZmNMTGVBQkxFNEJOSk9zUTR2bkJISgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t",
  "signedEntryTimestamp": "MEUCIQCUmBbbcNVQZheORGqGbdz4PBajob1+j0p8nFbie5mUYAIgaL2tFFnMyGoFecxAnmbW1ZTFRGe1VjuUH4dh/c7fdQE=",
  "integratedTime": 1661763632,
  "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d",
  "logIndex": 3305621
}
```
We can extract and inspect the certificate file using `openssl`:
```console
$ cat signature | jq --raw-output '.certificate' | base64 -d | openssl x509 -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            6d:89:8a:2f:e8:ee:46:a4:dc:59:ff:67:e0:1b:ea:fb:51:60:df:2d
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: O = sigstore.dev, CN = sigstore-intermediate
        Validity
            Not Before: Aug 29 09:00:31 2022 GMT
            Not After : Aug 29 09:10:31 2022 GMT
        Subject: 
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:31:89:29:38:26:e5:4c:74:03:a8:e9:23:c7:7a:
                    43:67:90:6d:1d:f1:4e:15:00:73:fa:6a:f2:c6:39:
                    71:e2:ba:25:88:c3:3f:4e:0c:df:52:14:47:90:73:
                    80:43:60:bf:70:68:38:a4:77:54:c9:d6:e8:22:0d:
                    1f:b3:e7:51:d7
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                Code Signing
            X509v3 Subject Key Identifier: 
                F6:6C:86:7C:D6:75:F8:6D:C8:B3:EF:EB:AD:78:79:2F:C0:99:9C:DB
            X509v3 Authority Key Identifier: 
                keyid:DF:D3:E9:CF:56:24:11:96:F9:A8:D8:E9:28:55:A2:C6:2E:18:64:3F

            X509v3 Subject Alternative Name: critical
                email:daniel.bevenius@gmail.com
            1.3.6.1.4.1.57264.1.1: 
                https://github.com/login/oauth
            CT Precertificate SCTs: 
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 08:60:92:F0:28:52:FF:68:45:D1:D1:6B:27:84:9C:45:
                                67:18:AC:16:3D:C3:38:D2:6D:E6:BC:22:06:36:6F:72
                    Timestamp : Aug 29 09:00:31.903 2022 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:45:02:21:00:FA:28:5C:16:36:93:36:E7:FD:87:D4:
                                14:CB:95:FC:56:4B:3D:13:D0:42:87:F6:97:C4:11:07:
                                4C:3E:D0:FA:F5:02:20:5C:A7:ED:B7:DC:4F:EB:B0:22:
                                04:9F:31:79:CC:B4:F1:91:9E:22:9C:36:9E:72:2E:DC:
                                EE:FE:3E:D5:FA:36:61
    Signature Algorithm: ecdsa-with-SHA384
         30:64:02:30:10:4d:ec:55:35:d6:e0:f5:72:7e:6d:25:ce:f5:
         60:4e:68:ab:48:b2:b6:b1:f7:66:c3:b9:0d:84:95:15:f5:bd:
         d2:31:1c:3b:9e:d3:fc:4c:82:38:e9:15:e9:1d:3a:d5:02:30:
         66:e8:14:e1:eb:5d:c6:78:fb:32:c0:6e:4a:0b:62:f6:57:44:
         1e:ff:4f:a3:b7:60:67:07:8f:37:ae:93:27:5a:bb:a1:89:2a:
         9c:01:5b:6e:40:ec:89:3d:52:49:e2:3c
-----BEGIN CERTIFICATE-----
MIICpzCCAi6gAwIBAgIUbYmKL+juRqTcWf9n4Bvq+1Fg3y0wCgYIKoZIzj0EAwMw
NzEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MR4wHAYDVQQDExVzaWdzdG9yZS1pbnRl
cm1lZGlhdGUwHhcNMjIwODI5MDkwMDMxWhcNMjIwODI5MDkxMDMxWjAAMFkwEwYH
KoZIzj0CAQYIKoZIzj0DAQcDQgAEMYkpOCblTHQDqOkjx3pDZ5BtHfFOFQBz+mry
xjlx4roliMM/TgzfUhRHkHOAQ2C/cGg4pHdUydboIg0fs+dR16OCAU0wggFJMA4G
A1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQU9myG
fNZ1+G3Is+/rrXh5L8CZnNswHwYDVR0jBBgwFoAU39Ppz1YkEZb5qNjpKFWixi4Y
ZD8wJwYDVR0RAQH/BB0wG4EZZGFuaWVsLmJldmVuaXVzQGdtYWlsLmNvbTAsBgor
BgEEAYO/MAEBBB5odHRwczovL2dpdGh1Yi5jb20vbG9naW4vb2F1dGgwgYoGCisG
AQQB1nkCBAIEfAR6AHgAdgAIYJLwKFL/aEXR0WsnhJxFZxisFj3DONJt5rwiBjZv
cgAAAYLo1LsfAAAEAwBHMEUCIQD6KFwWNpM25/2H1BTLlfxWSz0T0EKH9pfEEQdM
PtD69QIgXKftt9xP67AiBJ8xecy08ZGeIpw2nnIu3O7+PtX6NmEwCgYIKoZIzj0E
AwMDZwAwZAIwEE3sVTXW4PVyfm0lzvVgTmirSLK2sfdmw7kNhJUV9b3SMRw7ntP8
TII46RXpHTrVAjBm6BTh613GePsywG5KC2L2V0Qe/0+jt2BnB483rpMnWruhiSqc
AVtuQOyJPVJJ4jw=
-----END CERTIFICATE-----
```

Verify the artifact:
```console
$ sigstore verify npm-example-1.0.0.tgz signature signingcert.pem
Verified OK
```

Now, in the sigstore-js README.md there is a reference to the Rekor url
that looks like it was "supposed" to be in the sign commands output. I was not
able to find this and opened https://github.com/sigstore/sigstore-js/pull/68 to
address this.

But if we have the url we can get entry inforation from Rekor:
```console
$ curl --silent https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058 | jq --raw-output '.[].body' | base64 --decode | jq
```

_work in progress_

### Embedded signing and verification
Currently [hawkbit] is storing binary firmware along with metadata. We should be
able sign the binary using sigstore and storing the signature and certificate
in the json metadata. This is then later downloaded/sent to the device during
a firmware update. 
Questions:
* Can we verify the signatur of these downloaded firmware blobs without having
to reach/call out to Rekor?

* Can we store the sigstore root CA to verify the signature without making and
external call.

### Get Fulcia root certificate
```console
$ curl -q https://fulcio.sigstore.dev/api/v1/rootCert | openssl x509 -text
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1531  100  1531    0     0   3147      0 --:--:-- --:--:-- --:--:--  3143
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            b9:d5:89:57:e7:53:46:eb:25:ab:26:46:41:eb:9f:f5:27:7d:a4
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: O = sigstore.dev, CN = sigstore
        Validity
            Not Before: Apr 13 20:06:15 2022 GMT
            Not After : Oct  5 13:56:58 2031 GMT
        Subject: O = sigstore.dev, CN = sigstore-intermediate
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    04:f1:15:52:ff:2b:07:f8:d3:af:b8:36:72:3c:86:
                    6d:8a:58:14:17:d3:65:6a:b6:29:01:df:47:3f:5b:
                    c1:04:7d:54:e4:25:7b:ec:b4:92:ee:cd:19:88:7e:
                    27:13:b1:ef:ee:9b:52:e8:bb:ef:47:f4:93:93:bf:
                    7c:2d:58:0c:cc:b9:49:e0:77:88:7c:5d:ed:1d:26:
                    9e:c4:b7:18:a5:20:12:af:59:12:d0:df:d1:80:12:
                    73:ff:d8:d6:0a:25:e7
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        X509v3 extensions:
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Extended Key Usage: 
                Code Signing
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Subject Key Identifier: 
                DF:D3:E9:CF:56:24:11:96:F9:A8:D8:E9:28:55:A2:C6:2E:18:64:3F
            X509v3 Authority Key Identifier: 
                keyid:58:C0:1E:5F:91:45:A5:66:A9:7A:CC:90:A1:93:22:D0:2A:C5:C5:FA

    Signature Algorithm: ecdsa-with-SHA384
         30:64:02:30:3c:2b:10:2b:80:d8:89:96:03:3c:86:83:8b:91:
         c5:2a:77:f1:5f:1e:80:49:25:66:11:17:ec:ca:76:01:89:7d:
         97:e9:22:51:9d:95:3c:e3:ff:43:65:d9:c5:be:fc:66:02:30:
         4e:b7:a4:29:06:57:38:27:fd:03:c6:f9:13:0a:aa:5c:96:fc:
         e2:2f:a0:42:08:f9:e3:76:52:01:dc:fb:b7:07:1b:0f:9b:28:
         14:63:b2:22:db:36:dd:09:d9:62:8a:8c
-----BEGIN CERTIFICATE-----
MIICGjCCAaGgAwIBAgIUALnViVfnU0brJasmRkHrn/UnfaQwCgYIKoZIzj0EAwMw
KjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y
MjA0MTMyMDA2MTVaFw0zMTEwMDUxMzU2NThaMDcxFTATBgNVBAoTDHNpZ3N0b3Jl
LmRldjEeMBwGA1UEAxMVc2lnc3RvcmUtaW50ZXJtZWRpYXRlMHYwEAYHKoZIzj0C
AQYFK4EEACIDYgAE8RVS/ysH+NOvuDZyPIZtilgUF9NlarYpAd9HP1vBBH1U5CV7
7LSS7s0ZiH4nE7Hv7ptS6LvvR/STk798LVgMzLlJ4HeIfF3tHSaexLcYpSASr1kS
0N/RgBJz/9jWCiXno3sweTAOBgNVHQ8BAf8EBAMCAQYwEwYDVR0lBAwwCgYIKwYB
BQUHAwMwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU39Ppz1YkEZb5qNjp
KFWixi4YZD8wHwYDVR0jBBgwFoAUWMAeX5FFpWapesyQoZMi0CrFxfowCgYIKoZI
zj0EAwMDZwAwZAIwPCsQK4DYiZYDPIaDi5HFKnfxXx6ASSVmERfsynYBiX2X6SJR
nZU84/9DZdnFvvxmAjBOt6QpBlc4J/0DxvkTCqpclvziL6BCCPnjdlIB3Pu3BxsP
mygUY7Ii2zbdCdliiow=
-----END CERTIFICATE-----

```

[hawkbit]: https://www.eclipse.org/hawkbit/
