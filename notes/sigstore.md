## sigstore
One of the main values of sigstore is to sign/validate/verify artifacts, like
thirdparty software dependencies, to avoid supply chain attacks. It has not been
very easy to sign code/modules/containers etc before which has led to people
simply not doing it. It is the software and also the maintaince of keys which
adds makes this difficult.

sigstore is a project under the CNFC and it goal is to provide a
software-signing equivalent to `Let's Encrypt`. It is not just one tool but a
collection of tools namely; `fulico`, `rekor`, and `cosign`. 

With sigstore we don't have to manage keys, and it makes it simpler to handle
revocation.

### Installation
```console
$ go install github.com/sigstore/cosign/cmd/cosign@latest
```

### Example command
The following section discuss and show output from running the following cosign
command:
```console
COSIGN_EXPERIMENTAL=1 \
../cosign sign-blob \
    --output-certificate firmware.crt \
    --output-signature firmware.sig \
    firmware.bin
```

### Fulcio
Is a root CA for code signing certs, and issues code-signing certificates.
Importantly it is an automatic certificate authority.

Before we can send a certificate request to Fulcio we need to first accuire an
OpenID Connect token. This token will be a JSON Web Token (JWT) and is a base64
encoded string with three parts:
```
base64(header).base64(payload).signature
```
For example, a decoded JWT might look like this:
Header:
```json
{
  "alg": "RS256",
  "kid": "9a3e6e2cf1821e020288a8c380a6856b16aae69f"
}
```json
Payload:
```
{
  "iss": "https://oauth2.sigstore.dev/auth",
  "sub": "CgY0MzIzNTESJmh0dHBzOiUyRiUyRmdpdGh1Yi5jb20lMkZsb2dpbiUyRm9hdXRo",
  "aud": "sigstore",
  "exp": 1668669015,
  "iat": 1668668955,
  "nonce": "2HfGuvSQXxt99jj0vA3Q4i4z3PR",
  "at_hash": "EFHCQ52e1Wy43Z9Buzow_A",
  "c_hash": "y5o-9uXlkDrnKgX28-DLIw",
  "email": "daniel.bevenius@gmail.com",
  "email_verified": true,
  "federated_claims": {
    "connector_id": "https://github.com/login/oauth",
    "user_id": "432351"
  }
}
```
Signature:
```console
rTMenbpytO2EqK9LQmHaFltwO4RLaWOrYHuS7MOEzIEv-4dmbxEr2oJTdgpLTnEDFqoLEp3TLEfyr9OO8CYYIVUJcUydhIILWWOC1zKlA56gwU-17uzvlImj6kucN9ezHfScaKl-Mkv4zmxXtrLBxjIKKC6T63H0pyUzj0e_uLS-W3yzxOQbqs-LLOKaRPJGeftDNvHI7B2GfWlpVLwABkc3qNH7Sh1lmfTrGmZ3QyGQ6Vi-apmqzcuBTkCKTeqqg4fYi_Vtw7GkGXYeN0PIEW3oYJ3WOObzvSyRSbzxLsziyQDq9HRzxZloBJk0EPBSoC3qvj6-qYh7ZLf2W5-0Og
```
Now if we look at the header we see that we have an algorithm which in this case
is RSA 256, and a key id. This is the public key id that can be used to verify
the signature of the header and payload. This signature was generated by the
identity providers its private key. So how do we find the public key?  
There is a public endpoint exposed by most identity providers that can be used
get information about the identity provider:
```console
$ curl -s  https://oauth2.sigstore.dev/auth/.well-known/openid-configuration | jq '.jwks_uri'
"https://oauth2.sigstore.dev/auth/keys"
```
And we can use that url to find out information about the keys:
```console
$ curl -s https://oauth2.sigstore.dev/auth/keys | jq
{
  "keys": [
    {
      "use": "sig",
      "kty": "RSA",
      "kid": "9a3e6e2cf1821e020288a8c380a6856b16aae69f",
      "alg": "RS256",
      "n": "vuS5WUPi3m2fbfLFWdYqOUifg0-x0IW1vbtCklG4mUielqmEMgHOQmc47ZRi39LWw2fZUJmfp-q3R0wEJruDv1ZIKHQugKZpT2xqN936jV2Jtrz_WcBHHGZM9XfaOVbh_WnukjaLPtHkvX_bu3dl-dWYNF0IGA2OmmTOp4heQeqFujBaFWb9ZKbzo9pOIFwKDwKjWMgnLVDMHmEV2UmB6pad7zoMQEPMxUDHr2bSNDL9QicewBJcrVMKd-QDwZ8p4T3dNfnA9Lztrx6A-Pb7VH5x2AAtAcWNcMKXWnHd5QoGkCzyBdY5LBvqDUhBmY2ek7rH4F54L7VJx6tvZNiRxQ",
      "e": "AQAB"
    },
    {
      "use": "sig",
      "kty": "RSA",
      "kid": "1456029e0714f659284b99cc6b27bdd61a455d7f",
      "alg": "RS256",
      "n": "9fZODOmWJINdAetTxzZkLnk3Vr9_jb6--NX284FQtxIxb-tbHR8oEW94Wl-moe76pGfk0SFJac2uq6_C-805kkaqgIQqgES_CCD0-8BXikdY1-5Q-dj6yQU98GUhrRDxx-WsdGnyrbsSrUre32_WQkaEQEP2IcEo63b3Y4F4WZ8arBFua_rYz0uwR3oX7HuOTIhGi5R6oy_FSsx2NYxlqnJxSWc7vv9GiQ3WabRtAN2OiETSIM-SNpRCjf7WngfBq2gcSvPJ8mp-epARPQUe0FCevZT_dq4YU29okOn9mRwo_s7eiy-9JIuTWbTYmUyobERXFaEMWSzpyzC_f6ts_w",
      "e": "AQAB"
    }
  ]
AQAB}
```
So we have `n` and `e` which together make out the public key in RSA.
```console
$ curl -s https://oauth2.sigstore.dev/auth/keys | jq -c '.keys[] | select (.kid | contains("1456029e0714f659284b99cc6b27bdd61a455d7f"))' | jq '.n'

$ curl -s https://oauth2.sigstore.dev/auth/keys | jq -c '.keys[] | select (.kid | contains("1456029e0714f659284b99cc6b27bdd61a455d7f"))' | jq '.e' | tr '"' ' ' | xargs > pub-exponent
```
We can decode this into
```
$ openssl rsa -pubin -in pubkey.pem -text -noout
RSA Public-Key: (2048 bit)
Modulus:
    00:f5:f6:4e:0c:e9:96:24:83:5d:01:eb:53:c7:36:
    64:2e:79:37:56:bf:7f:8d:be:be:f8:d5:f6:f3:81:
    50:b7:12:31:6f:eb:5b:1d:1f:28:11:6f:78:5a:5f:
    a6:a1:ee:fa:a4:67:e4:d1:21:49:69:cd:ae:ab:af:
    c2:fb:cd:39:92:46:aa:80:84:2a:80:44:bf:08:20:
    f4:fb:c0:57:8a:47:58:d7:ee:50:f9:d8:fa:c9:05:
    3d:f0:65:21:ad:10:f1:c7:e5:ac:74:69:f2:ad:bb:
    12:ad:4a:de:df:6f:d6:42:46:84:40:43:f6:21:c1:
    28:eb:76:f7:63:81:78:59:9f:1a:ac:11:6e:6b:fa:
    d8:cf:4b:b0:47:7a:17:ec:7b:8e:4c:88:46:8b:94:
    7a:a3:2f:c5:4a:cc:76:35:8c:65:aa:72:71:49:67:
    3b:be:ff:46:89:0d:d6:69:b4:6d:00:dd:8e:88:44:
    d2:20:cf:92:36:94:42:8d:fe:d6:9e:07:c1:ab:68:
    1c:4a:f3:c9:f2:6a:7e:7a:90:11:3d:05:1e:d0:50:
    9e:bd:94:ff:76:ae:18:53:6f:68:90:e9:fd:99:1c:
    28:fe:ce:de:8b:2f:bd:24:8b:93:59:b4:d8:99:4c:
    a8:6c:44:57:15:a1:0c:59:2c:e9:cb:30:bf:7f:ab:
    6c:ff
Exponent: 65537 (0x10001)
```
So the verifying party can indeed get the public key by using the `kid` and
the public endpoint to get the modulus and the public exponent.
TODO: check in scripts that shows these steps.

For more information about jws see [jwt.md](./jwt.md).

The JWT, which is base64 encoded, is set in the http header of the certificate
request that is then sent to Fulcio
```json
{
  "publicKey": {
    "content": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE6LMMj8/QTpGz5gC4TGaFi3jLPh7qwXEewB1Hl2TX2FH/N5ZmoYU0ZlhHm7tGQOY03UwBpIKlGh9yobp2/NAJzQ==",
    "algorithm": "ecdsa"
  },
  "signedEmailAddress": "MEUCIQCaryidkKEVkSNnI+t4uoWolyxpfUWVukp/CWunzFW2HgIgfzJC2+JP0sjfX8nNaTL1tmpPYnco11hrJnllLex31Ro=",
  "certificateSigningRequest": null
}
```
Now, the client will generate a keypair for this communication and send the
public key as shown above, the private key of this pair will have been used to
sign the email address.


The certificates that Fulicio provides are not like the ones we use for TLS but
they are intended for code signing.
```console
 base64 -d  firmwarecrt | openssl x509 --noout --text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            23:6f:80:29:d7:da:ad:93:d0:17:67:c3:49:df:fa:ce:59:ed:06:33
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: O = sigstore.dev, CN = sigstore-intermediate
        Validity
            Not Before: Nov 17 07:09:15 2022 GMT
            Not After : Nov 17 07:19:15 2022 GMT
        Subject: 
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:a7:cf:ac:cc:a1:65:3b:c0:e7:09:ac:2d:12:68:
                    c1:57:a3:48:9f:4e:fd:3a:d8:37:cd:9c:03:95:f3:
                    38:b5:b6:1d:27:60:98:2b:d8:33:ee:76:88:91:c8:
                    08:42:d6:ae:58:1a:d9:cc:59:97:5f:7d:8f:0e:e6:
                    02:bd:29:86:f6
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                Code Signing
            X509v3 Subject Key Identifier: 
                01:1D:36:CB:AC:36:6E:9D:71:C1:A1:6F:88:6F:CB:5C:96:5B:10:31
            X509v3 Authority Key Identifier: 
                keyid:DF:D3:E9:CF:56:24:11:96:F9:A8:D8:E9:28:55:A2:C6:2E:18:64:3F

            X509v3 Subject Alternative Name: critical
                email:daniel.bevenius@gmail.com
            1.3.6.1.4.1.57264.1.1: 
                https://github.com/login/oauth
            CT Precertificate SCTs: 
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : DD:3D:30:6A:C6:C7:11:32:63:19:1E:1C:99:67:37:02:
                                A2:4A:5E:B8:DE:3C:AD:FF:87:8A:72:80:2F:29:EE:8E
                    Timestamp : Nov 17 07:09:15.629 2022 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:45:02:21:00:89:F4:6A:A2:B9:2F:D2:38:12:F6:0A:
                                16:EA:FA:18:B7:07:D1:B4:0D:33:F6:BE:67:F7:FC:4A:
                                9D:58:71:46:39:02:20:6A:C9:B9:A1:DE:EA:CE:D2:AB:
                                6C:83:6E:AF:30:92:66:A7:07:3B:3C:8A:9C:59:FF:68:
                                60:07:8A:B8:D6:A5:BD
    Signature Algorithm: ecdsa-with-SHA384
         30:65:02:30:27:0a:2f:e8:ed:19:9e:80:f5:f6:5c:86:33:d5:
         9f:3a:f1:07:83:46:95:83:c1:ed:3a:fb:30:33:66:a0:87:7d:
         90:0c:97:73:87:1e:aa:66:6f:ce:f0:1f:60:7e:c0:41:02:31:
         00:f3:73:f4:fc:e0:4f:5d:cf:c2:f7:39:ca:f2:ed:cb:af:55:
         09:02:8e:23:36:cc:91:22:c6:1e:3e:78:05:55:6d:a5:96:93:
         24:9e:eb:f3:7b:09:c9:ff:f4:53:21:a3:82
```
For the meaning of critical see [certificates.md](./certificates.md).

The `Subject` field is also different. This is typically a domain name in a TLS
certificate but in a code-signing certificate these are email addresses (people)
or SPIFFE SVID (workloads).

Fulcio has to validate the user/system that is requesting a certificate to be
created for it. OpenID Connect (OIDC) can be used so it will handle the email
address, Fulcio signs X.509 certificates valid for 10 minutes.

Every certificate issued will be appended to a public Certificate Transparency
(CT) log. This log can be inspected by anyone and the certificates can be used
to verify signatures. The CT log is specified in
[RFC-6962](https://www.rfc-editor.org/rfc/rfc6962.html). This allows anyone to
audit/check issued certificates.
This is not to be confused with Rekor which is the transparency log which stores
signed artifacts and attestations.

So Fulcio will first create a special x.509 extension called a poision extension
in the certifiate before it is added to the CT log. This kind of cert is called
a pre-certifcate and is not useful by clients at this stage.

The response from the CT is a Signed Certificate Timestamp (SCT) which is a
promise of inclusion in the CT log.
Now, this SCT is embedded into the certificate and it is signed again to include
this information in the signature. Then the certificate is returned to the
client.

The `cosign sign-blob` command will also uplaod a rekord to Rekor.

## Rekor
Is the transparency log which is immutable, append only log which can be used
other parties to check what was signed and by whom.

It can hold signed metadata generated by a software projects supply chain. 
So a project can sign any metadata about and have this metadata recorded in
Rekor. This allows consumers of the artifacts that the metadata is about to
verify and either trust or not trust the artifacts.
Note that Rekor does not store the actual data we are signing which is a good
thing this could mean that it would require a lot of storage, but also that data
might be private.

So in what format does Rekor store the data it handles?  
Rekor allows for pluggable-types, or schemas, for what is stored in the log.

The currently supported schemas can be found in
[openapi.yaml](https://github.com/sigstore/rekor/blob/main/openapi.yaml).

The example we have been using will upload a json object that looks like this:
```json
{
  "apiVersion": "0.0.1",
  "spec": {
    "data": {
      "hash": {
        "algorithm": "sha256",
        "value": "311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95"
      }
    },
    "signature": {
      "content": "MEYCIQCd0q6y+7zYTiGHd4Ej6IHDJ5FTiXQTJiiYcpgHYwSclAIhALHGzEMYUlTqPOETIaCoYZIAFDHHlt16wE15FtUzAidS",
      "publicKey": {
        "content": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNxRENDQWk2Z0F3SUJBZ0lVSTIrQUtkZmFyWlBRRjJmRFNkLzZ6bG50QmpNd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJeE1URTNNRGN3T1RFMVdoY05Nakl4TVRFM01EY3hPVEUxV2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVwOCtzektGbE84RG5DYXd0RW1qQlY2TkluMDc5T3RnM3pad0QKbGZNNHRiWWRKMkNZSzlnejduYUlrY2dJUXRhdVdCclp6Rm1YWDMyUER1WUN2U21HOXFPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVVBUjAyCnk2dzJicDF4d2FGdmlHL0xYSlpiRURFd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdEZFBUQnF4c2NSTW1NWkhoeVpaemNDb2twZXVONDhyZitIaW5LQUx5bnUKamdBQUFZU0VhNXZ0QUFBRUF3QkhNRVVDSVFDSjlHcWl1Uy9TT0JMMkNoYnEraGkzQjlHMERUUDJ2bWYzL0VxZApXSEZHT1FJZ2FzbTVvZDdxenRLcmJJTnVyekNTWnFjSE96eUtuRm4vYUdBSGlyaldwYjB3Q2dZSUtvWkl6ajBFCkF3TURhQUF3WlFJd0p3b3Y2TzBabm9EMTlseUdNOVdmT3ZFSGcwYVZnOEh0T3Zzd00yYWdoMzJRREpkemh4NnEKWm0vTzhCOWdmc0JCQWpFQTgzUDAvT0JQWGMvQzl6bks4dTNMcjFVSkFvNGpOc3lSSXNZZVBuZ0ZWVzJsbHBNawpudXZ6ZXduSi8vUlRJYU9DCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
      }
    }
  },
  "kind": "hashedrekord"
```
Now if we take a look at the `spec.hash.value' we can see that it is the same
value as the data we signed (firmware.bin):
```console
$ sha256sum firmware.bin 
311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95  firmware.bin
```
And we can see that 'signature.content' matches the signature that was returned
from Fulcio:
```console
$ cat firmware.sig 
MEYCIQCd0q6y+7zYTiGHd4Ej6IHDJ5FTiXQTJiiYcpgHYwSclAIhALHGzEMYUlTqPOETIaCoYZIAFDHHlt16wE15FtUzAidS
```

And we can see the `signature.publicKey.content` matches the certificate that
we got from Fulcio:
```console
$ cat firmware.crt 
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNxRENDQWk2Z0F3SUJBZ0lVSTIrQUtkZmFyWlBRRjJmRFNkLzZ6bG50QmpNd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJeE1URTNNRGN3T1RFMVdoY05Nakl4TVRFM01EY3hPVEUxV2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVwOCtzektGbE84RG5DYXd0RW1qQlY2TkluMDc5T3RnM3pad0QKbGZNNHRiWWRKMkNZSzlnejduYUlrY2dJUXRhdVdCclp6Rm1YWDMyUER1WUN2U21HOXFPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVVBUjAyCnk2dzJicDF4d2FGdmlHL0xYSlpiRURFd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdEZFBUQnF4c2NSTW1NWkhoeVpaemNDb2twZXVONDhyZitIaW5LQUx5bnUKamdBQUFZU0VhNXZ0QUFBRUF3QkhNRVVDSVFDSjlHcWl1Uy9TT0JMMkNoYnEraGkzQjlHMERUUDJ2bWYzL0VxZApXSEZHT1FJZ2FzbTVvZDdxenRLcmJJTnVyekNTWnFjSE96eUtuRm4vYUdBSGlyaldwYjB3Q2dZSUtvWkl6ajBFCkF3TURhQUF3WlFJd0p3b3Y2TzBabm9EMTlseUdNOVdmT3ZFSGcwYVZnOEh0T3Zzd00yYWdoMzJRREpkemh4NnEKWm0vTzhCOWdmc0JCQWpFQTgzUDAvT0JQWGMvQzl6bks4dTNMcjFVSkFvNGpOc3lSSXNZZVBuZ0ZWVzJsbHBNawpudXZ6ZXduSi8vUlRJYU9DCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K$
```

So, from our command that is what is sent to Rekor, that is a hash over the data
and not the data itself. The signature over that hash, and the certificate that
can be used to verfity the signature. At least that is my understanding of how
things work. 

The response from Rekor will be a log entry:
```console
cat logentry.json  | jq
{
  "body": "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzMTEzNzU5MDhiMmExMDY4OGZiODg0MWI2MWQ4YjFkYWE5YTNlOTA0Zjg0ZDJlZDg4ZDBhMzVjYjRmMGUxYTk1In19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FWUNJUUNkMHE2eSs3ellUaUdIZDRFajZJSERKNUZUaVhRVEppaVljcGdIWXdTY2xBSWhBTEhHekVNWVVsVHFQT0VUSWFDb1laSUFGREhIbHQxNndFMTVGdFV6QWlkUyIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2sxSlNVTnhSRU5EUVdrMlowRjNTVUpCWjBsVlNUSXJRVXRrWm1GeVdsQlJSakptUkZOa0x6WjZiRzUwUW1wTmQwTm5XVWxMYjFwSmVtb3dSVUYzVFhjS1RucEZWazFDVFVkQk1WVkZRMmhOVFdNeWJHNWpNMUoyWTIxVmRWcEhWakpOVWpSM1NFRlpSRlpSVVVSRmVGWjZZVmRrZW1SSE9YbGFVekZ3WW01U2JBcGpiVEZzV2tkc2FHUkhWWGRJYUdOT1RXcEplRTFVUlROTlJHTjNUMVJGTVZkb1kwNU5ha2w0VFZSRk0wMUVZM2hQVkVVeFYycEJRVTFHYTNkRmQxbElDa3R2V2tsNmFqQkRRVkZaU1V0dldrbDZhakJFUVZGalJGRm5RVVZ3T0N0emVrdEdiRTg0Ukc1RFlYZDBSVzFxUWxZMlRrbHVNRGM1VDNSbk0zcGFkMFFLYkdaTk5IUmlXV1JLTWtOWlN6bG5lamR1WVVsclkyZEpVWFJoZFZkQ2NscDZSbTFZV0RNeVVFUjFXVU4yVTIxSE9YRlBRMEZWTUhkblowWktUVUUwUndwQk1WVmtSSGRGUWk5M1VVVkJkMGxJWjBSQlZFSm5UbFpJVTFWRlJFUkJTMEpuWjNKQ1owVkdRbEZqUkVGNlFXUkNaMDVXU0ZFMFJVWm5VVlZCVWpBeUNuazJkekppY0RGNGQyRkdkbWxITDB4WVNscGlSVVJGZDBoM1dVUldVakJxUWtKbmQwWnZRVlV6T1ZCd2VqRlphMFZhWWpWeFRtcHdTMFpYYVhocE5Ga0tXa1E0ZDBwM1dVUldVakJTUVZGSUwwSkNNSGRITkVWYVdrZEdkV0ZYVm5OTWJVcHNaRzFXZFdGWVZucFJSMlIwV1Zkc2MweHRUblppVkVGelFtZHZjZ3BDWjBWRlFWbFBMMDFCUlVKQ1FqVnZaRWhTZDJONmIzWk1NbVJ3WkVkb01WbHBOV3BpTWpCMllrYzVibUZYTkhaaU1rWXhaRWRuZDJkWmIwZERhWE5IQ2tGUlVVSXhibXREUWtGSlJXWkJValpCU0dkQlpHZEVaRkJVUW5GNGMyTlNUVzFOV2tob2VWcGFlbU5EYjJ0d1pYVk9ORGh5Wml0SWFXNUxRVXg1Ym5VS2FtZEJRVUZaVTBWaE5YWjBRVUZCUlVGM1FraE5SVlZEU1ZGRFNqbEhjV2wxVXk5VFQwSk1Na05vWW5FcmFHa3pRamxITUVSVVVESjJiV1l6TDBWeFpBcFhTRVpIVDFGSloyRnpiVFZ2WkRkeGVuUkxjbUpKVG5WeWVrTlRXbkZqU0U5NmVVdHVSbTR2WVVkQlNHbHlhbGR3WWpCM1EyZFpTVXR2V2tsNmFqQkZDa0YzVFVSaFFVRjNXbEZKZDBwM2IzWTJUekJhYm05RU1UbHNlVWROT1ZkbVQzWkZTR2N3WVZabk9FaDBUM1p6ZDAweVlXZG9NekpSUkVwa2VtaDRObkVLV20wdlR6aENPV2RtYzBKQ1FXcEZRVGd6VURBdlQwSlFXR012UXpsNmJrczRkVE5NY2pGVlNrRnZOR3BPYzNsU1NYTlpaVkJ1WjBaV1Z6SnNiSEJOYXdwdWRYWjZaWGR1U2k4dlVsUkpZVTlEQ2kwdExTMHRSVTVFSUVORlVsUkpSa2xEUVZSRkxTMHRMUzBLIn19fX0=",
  "integratedTime": 1668668956,
  "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d",
  "logIndex": 7257243,
  "verification": {
    "inclusionProof": {
      "checkpoint": "rekor.sigstore.dev - 2605736670972794746\n3093813\noxeC1ADPhXe1kAfHfarju6sBF59FXLEQ+9a/6tG+Nw0=\nTimestamp: 1668668956499493067\n\n— rekor.sigstore.dev wNI9ajBEAiBXRrpFSv5wvAs8Y7HhhIt4fohFciubpp6wX9UdnjF3vAIgfdRpAK6+/DfHe0jb6PkyG0hfylWkCCVfhMfGKntB61k=\n",
      "hashes": [
        "65a0aba5d75dcd8e3fd0b551dd0d4ffd6972c0a60360a35398e5cf25fda3b002",
        "06d367abc373cda7531ac9ca302afce88cc24ff57b1731e13c8251b7f0b0282f",
        "798ea9dfe348671b9a0570cbf5314df3cfdc2ca50d0f5cae5b94c065e35cd719",
        "bf4f21e35771b64629af8fab20212c89f14a1bd21aa40c25adf35f58a9914729",
        "9428810f5b8380d30e8e4ffb5e46a561de3aa979dfee33ed3297edf253f29862",
        "b4f1e7db3e4f4ad295073af3085ec987c8a6997be537a2d027d7ca58fb295f7a",
        "1184c2a7a2094b4b8ec5eb58d5a0fce22dae2a68eca3230d92c113c60dc812ac",
        "fc77f10859b9c663ac33a28d4f72203326a7dbd0fa45acd8655fa536b290232d",
        "be4c4c0f9190fd5be4b2498ef7cc28a90d9818ce00ee8b3389121b4ba3eff4ba",
        "9a991dc567e6dd4fa21d6235df691252ca81eab5e1301c849c8aa2151363e6a7",
        "732af72ebcc0c8a16dbdba657c7b755d2097691d08882f308dbc5b133372c170",
        "2747468d0ed5e5b1138bba7b7968367a9842437d9004b3166391f115cb867d1e"
      ],
      "logIndex": 3093812,
      "rootHash": "a31782d400cf8577b59007c77daae3bbab01179f455cb110fbd6bfead1be370d",
      "treeSize": 3093813
    },
    "signedEntryTimestamp": "MEQCIB2iQ2cM80vbtSW+aG+TyUl3GrEs3K5r8ZyJgEo5mHlXAiBGuL5HTLoO1aplgcWDpAmpO+aMvrL7g8L/i50vP3flbg=="
  }
}
```
Now, the body is base64 encoded which we can inspect using:
```console
$ jq --raw-output '.body' logentry.json | base64 --decode | jq --sort-keys
{
  "apiVersion": "0.0.1",
  "kind": "hashedrekord",
  "spec": {
    "data": {
      "hash": {
        "algorithm": "sha256",
        "value": "311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95"
      }
    },
    "signature": {
      "content": "MEYCIQCd0q6y+7zYTiGHd4Ej6IHDJ5FTiXQTJiiYcpgHYwSclAIhALHGzEMYUlTqPOETIaCoYZIAFDHHlt16wE15FtUzAidS",
      "publicKey": {
        "content": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNxRENDQWk2Z0F3SUJBZ0lVSTIrQUtkZmFyWlBRRjJmRFNkLzZ6bG50QmpNd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJeE1URTNNRGN3T1RFMVdoY05Nakl4TVRFM01EY3hPVEUxV2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVwOCtzektGbE84RG5DYXd0RW1qQlY2TkluMDc5T3RnM3pad0QKbGZNNHRiWWRKMkNZSzlnejduYUlrY2dJUXRhdVdCclp6Rm1YWDMyUER1WUN2U21HOXFPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVVBUjAyCnk2dzJicDF4d2FGdmlHL0xYSlpiRURFd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdEZFBUQnF4c2NSTW1NWkhoeVpaemNDb2twZXVONDhyZitIaW5LQUx5bnUKamdBQUFZU0VhNXZ0QUFBRUF3QkhNRVVDSVFDSjlHcWl1Uy9TT0JMMkNoYnEraGkzQjlHMERUUDJ2bWYzL0VxZApXSEZHT1FJZ2FzbTVvZDdxenRLcmJJTnVyekNTWnFjSE96eUtuRm4vYUdBSGlyaldwYjB3Q2dZSUtvWkl6ajBFCkF3TURhQUF3WlFJd0p3b3Y2TzBabm9EMTlseUdNOVdmT3ZFSGcwYVZnOEh0T3Zzd00yYWdoMzJRREpkemh4NnEKWm0vTzhCOWdmc0JCQWpFQTgzUDAvT0JQWGMvQzl6bks4dTNMcjFVSkFvNGpOc3lSSXNZZVBuZ0ZWVzJsbHBNawpudXZ6ZXduSi8vUlRJYU9DCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
      }
    }
  }
}
```
Notice that this matches the content we uploaded.
And the `signedEntryTimestamp` is evidence that it was added to the log:
```console
$ cat logentry.json | jq '.verification.signedEntryTimestamp'
"MEQCIB2iQ2cM80vbtSW+aG+TyUl3GrEs3K5r8ZyJgEo5mHlXAiBGuL5HTLoO1aplgcWDpAmpO+aMvrL7g8L/i50vP3flbg=="
```

It has a restful API server, https://rekor.sigstore.dev.
Example of retrieving a log entry can be done using:
```
$ curl -s https://rekor.sigstore.dev/api/v1/log/entries?logIndex=3321511 | jq
```

Installing `rekor-cli`:
```console
$ go install -v github.com/sigstore/rekor/cmd/rekor-cli@latest
```

### cosign
Is a signing tool which I think is named after container signing but it can be
used to sign anything blob of data.

Signing steps:
* A keypair for code signing is generated.
* The user authenticates to an OpenID Connect Provider (OIDC) to verify the ownership of their email address.
* Upon successful authentication a code-signing cert is received.
* The code-signing cert is published to Rekor, the transparency log.
* User signs an artifact using the certificatate and the private key from the keypair.
* The signature from the signed artifact is published to Rekor.
* The keypair used are deleted
* The signed artifact can be published.


#### Blob signing
Even though cosign "has container in its name" it can be used to store other
types of files. We can store any blob we like using `cosign upload blob`:

First create a file that we want to upload:
```console
$ echo "bajja" > artifact
```
Next, we can hash this file using:
```console
$ shasum -a 258 artifact
311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95 artifact
```
Create a unique name for the file to be uploaded:
```console
$ uuidgen | head -c 8
c408de42
```
We can take that and c408de42 and use it in a name to make our artifact name
unique, for example `danbev/c408de42`.

Now, upload the blob using cosign to [ttl.sh](https://ttl.sh/):
```console
$ cosign upload blob -f artifact ttl.sh/danbev/c408de42:2h
Uploading file from [artifact] to [ttl.sh/danbev/c408de42:2h] with media type [text/plain]
File [artifact] is available directly at
[ttl.sh/v2/danbev/c408de42/blobs/sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95]

Uploaded image to:
ttl.sh/danbev/c408de42@sha256:7502069007aa8fb8319c139f29fbdd511f288607ce1dd183bda06fcca783536
```
So the artifact, in this case just a file is available using the url displayed
above:
```console
$ curl -L ttl.sh/v2/test-blob-upload-c408de42/blobs/sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95 > fetched-artifact
```
Notice that the url contains the sha256 digest:
```
sha256:311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95
```
```console
$ shasum -a 256 fetched-artifact 
311375908b2a10688fb8841b61d8b1daa9a3e904f84d2ed88d0a35cb4f0e1a95  fetched-artifact
```

We can now sign the blob using:
```console
$ cosign sign --key cosign.key ttl.sh/danbev/c408de42:2h
Enter password for private key: 
WARNING: Image reference ttl.sh/danbev/c408de42:2h uses a tag, not a digest, to identify the image to sign.

This can lead you to sign a different image than the intended one. Please use a
digest (example.com/ubuntu@sha256:abc123...) rather than tag
(example.com/ubuntu:latest) for the input to cosign. The ability to refer to
images by tag will be removed in a future release.
Pushing signature to: ttl.sh/danbev/c408de42
```

And to verify the blob:
```console
$ cosign verify --key cosign.pub ttl.sh/danbev/c408de42:2h | jq

Verification for ttl.sh/danbev/c408de42:2h --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
[
  {
    "critical": {
      "identity": {
        "docker-reference": "ttl.sh/danbev/c408de42"
      },
      "image": {
        "docker-manifest-digest": "sha256:7502069007aa8fb8319c139f29fbdd511f288607ce1dd183bda06fcca783536f"
      },
      "type": "cosign container image signature"
    },
    "optional": null
  }
]
```
We can save the signature using `cosign save`: 
```console
$ cosign save --dir out/ ttl.sh/danbev/c408de42:2h
```
And we can inspect it:
```console
$ ls out/
blobs  index.json  oci-layout
```

```console
$ cat out/index.json 
{
   "schemaVersion": 2,
   "manifests": [
      {
         "mediaType": "application/vnd.oci.image.manifest.v1+json",
         "size": 366,
         "digest": "sha256:7502069007aa8fb8319c139f29fbdd511f288607ce1dd183bda06fcca783536f",
         "annotations": {
            "kind": "dev.cosignproject.cosign/image"
         }
      },
      {
         "mediaType": "application/vnd.oci.image.manifest.v1+json",
         "size": 558,
         "digest": "sha256:3858bff64c98a08de76a0b9dcf90e66517c46b939c84680ed48d8090baccea52",
         "annotations": {
            "kind": "dev.cosignproject.cosign/sigs"
         }
      }
   ]
}
```

The image containing the signature can be found using `cosign triangulate`:
```console
$ cosign triangulate ttl.sh/danbev/c408de42:2h
ttl.sh/danbev/c408de42:sha256-7502069007aa8fb8319c139f29fbdd511f288607ce1dd183bda06fcca783536f.sig
```
Use `-d` to get debugging output.

We can also use `skopeo` to inspect the image that contains the signature:
```console
$ skopeo inspect --raw docker://$(cosign triangulate ttl.sh/danbev/c408de42:2h) | jq
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.oci.image.manifest.v1+json",
  "config": {
    "mediaType": "application/vnd.oci.image.config.v1+json",
    "size": 248,
    "digest": "sha256:287baa3058e11295538c4a97d8b0b9565955ea3ad721625c8412fb74d86d972e"
  },
  "layers": [
    {
      "mediaType": "application/vnd.dev.cosign.simplesigning.v1+json",
      "size": 238,
      "digest": "sha256:640e155f4ff1294c658cedf2acf4e49154ac976efa8fb298646dbddd47a6893f",
      "annotations": {
        "dev.cosignproject.cosign/signature": "MEUCICgRI1p03iFNnN5YwnA8I7yXdvsTK1ol5x8fc+D2xYcBAiEAya2rjeCbyR5VRJybGRz/fn92GdKGJIDtoAiyAfhqRYQ="
      }
    }
  ]
}
```

By default cosign will communicate with the remote registry to get the resources
required for the verification process resources. As shown above we can get the
resources and provided them instead, so there does not need to be any
interaction with the remote registry.

First, we get the signature using:
```console
$ skopeo inspect --raw docker://$(cosign triangulate ttl.sh/danbev/c408de42:2h) | jq -r '.layers[0].annotations["dev.cosignproject.cosign/signature"]' > danbev-blob.sig
```
Now, we can use this signature with `cosign verify`:
```console
$ cosign verify --signature=danbev-blob.sig --key cosign.pub ttl.sh/danbev/c408de42:2h | jq
```

We can instruct cosign to not upload the signature, and that it be stored in a
file instead, and also that the certificate be stored in a file.
```console
$ cosign sign --upload=false --output-signature=danbev-blob.sig --output-certificate=danbev-blob.crt --key cosign.key ttl.sh/danbev/c408de42:2h
```

And we can use those files to verify:
```console
$ cosign verify --signature=danbev-blob.sig --key danbev-blob.crt ttl.sh/danbev/c408de42:2h | jq
```

#### keyless signatures
These are when shortlived keys are used.
```console
$ COSIGN_EXPERIMENTAL=1 cosign sign $IMAGE_DIGEST
```

#### Trust Root
To verify the identity of a system we need to ask that system to present us
with credentials. And we then need to verify those credentials. To do this we
need to have something at the beginning of this flow that we trust can verify
these credentials. In WebPKI there are Root Certificate Authorities (CA) which
are built into browsers and OS's. A browser will check that a website has the
identity it claims by checking that it can be chained back to one of these
Root CA's.
In sigstores case the root trust allows users and systems to automatically
retreive digital certificates that prove who they are, and they use these
certs to sign artifacts that they produce and distribute. The users of these
artifacts can verify the signatures and certificates against the trust root.

### OpenID Connect
This is used for authentication.

### Signing JavaScript
First we have to install https://github.com/sigstore/sigstore-js and npm link
it:
```console
$ git clone https://github.com/sigstore/sigstore-js
$ npm i && npm r build
$ npm link
```


Next we have to generate the artifact to be signed:
```console
$ cd sigstore/npm-example
$ npm link sigstore
$ npm pack
```
This will generate a file named something like `npm-example-1.0.0.tgz`.
We can now sign this artifact using `sigstore`:
```console
$ which sigstore 
~/.nvm/versions/node/v18.4.0/bin/sigstore

$ sigstore sign ./npm-example-1.0.0.tgz > signature
Your browser will now be opened to: https://oauth2.sigstore.dev/auth/auth?response_type=code&client_id=sigstore&client_secret=&scope=openid+email&redirect_uri=http%3A%2F%2Flocalhost%3A45341&code_challenge=uL8NRr4KXZqeF3R5oi6YxBB17frl7WwjE6fengMrLuA&code_challenge_method=S256&state=lhufn6GM15TjGVmaxlIc2w&nonce=DOCLvVWN2UHTm6izNFaoLA
Created entry at index 4874058, available at
https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058
```
The above command will open a browser and ask for the Sigstore OAuth page. I
used GitHub as the identity provider to be used.

We can now inspect the generated `signature` file that was the output of the
above command:
```console
$ cat signature | jq
{
  "attestationType": "attestation/blob",
  "attestation": {
    "payloadHash": "4f2fb5c9d049ebad8d3d25f55ffdf49b290f7f84f56b89fe3d6663b48b856ad1",
    "payloadHashAlgorithm": "sha256",
    "signature": "MEYCIQDPnJgOdxFnx4Sb6XZRBnnThGfTGGFBgA6ZnQ/YE15GygIhAI9mlq+gAvSfSv/ilA0l90ogR2HSxntOQrd8FIsKMrS5"
  },
  "certificate": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNwekNDQWk2Z0F3SUJBZ0lVYlltS0wranVScVRjV2Y5bjRCdnErMUZnM3kwd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJd09ESTVNRGt3TURNeFdoY05Nakl3T0RJNU1Ea3hNRE14V2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVNWWtwT0NibFRIUURxT2tqeDNwRFo1QnRIZkZPRlFCeittcnkKeGpseDRyb2xpTU0vVGd6ZlVoUkhrSE9BUTJDL2NHZzRwSGRVeWRib0lnMGZzK2RSMTZPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVU5bXlHCmZOWjErRzNJcysvcnJYaDVMOENabk5zd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdBSVlKTHdLRkwvYUVYUjBXc25oSnhGWnhpc0ZqM0RPTkp0NXJ3aUJqWnYKY2dBQUFZTG8xTHNmQUFBRUF3QkhNRVVDSVFENktGd1dOcE0yNS8ySDFCVExsZnhXU3owVDBFS0g5cGZFRVFkTQpQdEQ2OVFJZ1hLZnR0OXhQNjdBaUJKOHhlY3kwOFpHZUlwdzJubkl1M083K1B0WDZObUV3Q2dZSUtvWkl6ajBFCkF3TURad0F3WkFJd0VFM3NWVFhXNFBWeWZtMGx6dlZnVG1pclNMSzJzZmRtdzdrTmhKVVY5YjNTTVJ3N250UDgKVElJNDZSWHBIVHJWQWpCbTZCVGg2MTNHZVBzeXdHNUtDMkwyVjBRZS8wK2p0MkJuQjQ4M3JwTW5XcnVoaVNxYwpBVnR1UU95SlBWSko0anc9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNHakNDQWFHZ0F3SUJBZ0lVQUxuVmlWZm5VMGJySmFzbVJrSHJuL1VuZmFRd0NnWUlLb1pJemowRUF3TXcKS2pFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUkV3RHdZRFZRUURFd2h6YVdkemRHOXlaVEFlRncweQpNakEwTVRNeU1EQTJNVFZhRncwek1URXdNRFV4TXpVMk5UaGFNRGN4RlRBVEJnTlZCQW9UREhOcFozTjBiM0psCkxtUmxkakVlTUJ3R0ExVUVBeE1WYzJsbmMzUnZjbVV0YVc1MFpYSnRaV1JwWVhSbE1IWXdFQVlIS29aSXpqMEMKQVFZRks0RUVBQ0lEWWdBRThSVlMveXNIK05PdnVEWnlQSVp0aWxnVUY5TmxhcllwQWQ5SFAxdkJCSDFVNUNWNwo3TFNTN3MwWmlING5FN0h2N3B0UzZMdnZSL1NUazc5OExWZ016TGxKNEhlSWZGM3RIU2FleExjWXBTQVNyMWtTCjBOL1JnQkp6LzlqV0NpWG5vM3N3ZVRBT0JnTlZIUThCQWY4RUJBTUNBUVl3RXdZRFZSMGxCQXd3Q2dZSUt3WUIKQlFVSEF3TXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBREFkQmdOVkhRNEVGZ1FVMzlQcHoxWWtFWmI1cU5qcApLRldpeGk0WVpEOHdId1lEVlIwakJCZ3dGb0FVV01BZVg1RkZwV2FwZXN5UW9aTWkwQ3JGeGZvd0NnWUlLb1pJCnpqMEVBd01EWndBd1pBSXdQQ3NRSzREWWlaWURQSWFEaTVIRktuZnhYeDZBU1NWbUVSZnN5bllCaVgyWDZTSlIKblpVODQvOURaZG5GdnZ4bUFqQk90NlFwQmxjNEovMER4dmtUQ3FwY2x2emlMNkJDQ1BuamRsSUIzUHUzQnhzUApteWdVWTdJaTJ6YmRDZGxpaW93PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlCOXpDQ0FYeWdBd0lCQWdJVUFMWk5BUEZkeEhQd2plRGxvRHd5WUNoQU8vNHdDZ1lJS29aSXpqMEVBd013CktqRVZNQk1HQTFVRUNoTU1jMmxuYzNSdmNtVXVaR1YyTVJFd0R3WURWUVFERXdoemFXZHpkRzl5WlRBZUZ3MHkKTVRFd01EY3hNelUyTlRsYUZ3MHpNVEV3TURVeE16VTJOVGhhTUNveEZUQVRCZ05WQkFvVERITnBaM04wYjNKbApMbVJsZGpFUk1BOEdBMVVFQXhNSWMybG5jM1J2Y21Vd2RqQVFCZ2NxaGtqT1BRSUJCZ1VyZ1FRQUlnTmlBQVQ3ClhlRlQ0cmIzUFFHd1M0SWFqdExrMy9PbG5wZ2FuZ2FCY2xZcHNZQnI1aSs0eW5CMDdjZWIzTFAwT0lPWmR4ZXgKWDY5YzVpVnV5SlJRK0h6MDV5aStVRjN1QldBbEhwaVM1c2gwK0gyR0hFN1NYcmsxRUM1bTFUcjE5TDlnZzkyagpZekJoTUE0R0ExVWREd0VCL3dRRUF3SUJCakFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQjBHQTFVZERnUVdCQlJZCndCNWZrVVdsWnFsNnpKQ2hreUxRS3NYRitqQWZCZ05WSFNNRUdEQVdnQlJZd0I1ZmtVV2xacWw2ekpDaGt5TFEKS3NYRitqQUtCZ2dxaGtqT1BRUURBd05wQURCbUFqRUFqMW5IZVhacCsxM05XQk5hK0VEc0RQOEcxV1dnMXRDTQpXUC9XSFBxcGFWbzBqaHN3ZU5GWmdTczBlRTd3WUk0cUFqRUEyV0I5b3Q5OHNJa29GM3ZaWWRkMy9WdFdCNWI5ClROTWVhN0l4L3N0SjVUZmNMTGVBQkxFNEJOSk9zUTR2bkJISgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t",
  "signedEntryTimestamp": "MEUCIQCUmBbbcNVQZheORGqGbdz4PBajob1+j0p8nFbie5mUYAIgaL2tFFnMyGoFecxAnmbW1ZTFRGe1VjuUH4dh/c7fdQE=",
  "integratedTime": 1661763632,
  "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d",
  "logIndex": 3305621
}
```
We can extract and inspect the certificate file using `openssl`:
```console
$ cat signature | jq --raw-output '.certificate' | base64 -d | openssl x509 -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            6d:89:8a:2f:e8:ee:46:a4:dc:59:ff:67:e0:1b:ea:fb:51:60:df:2d
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: O = sigstore.dev, CN = sigstore-intermediate
        Validity
            Not Before: Aug 29 09:00:31 2022 GMT
            Not After : Aug 29 09:10:31 2022 GMT
        Subject: 
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:31:89:29:38:26:e5:4c:74:03:a8:e9:23:c7:7a:
                    43:67:90:6d:1d:f1:4e:15:00:73:fa:6a:f2:c6:39:
                    71:e2:ba:25:88:c3:3f:4e:0c:df:52:14:47:90:73:
                    80:43:60:bf:70:68:38:a4:77:54:c9:d6:e8:22:0d:
                    1f:b3:e7:51:d7
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                Code Signing
            X509v3 Subject Key Identifier: 
                F6:6C:86:7C:D6:75:F8:6D:C8:B3:EF:EB:AD:78:79:2F:C0:99:9C:DB
            X509v3 Authority Key Identifier: 
                keyid:DF:D3:E9:CF:56:24:11:96:F9:A8:D8:E9:28:55:A2:C6:2E:18:64:3F

            X509v3 Subject Alternative Name: critical
                email:daniel.bevenius@gmail.com
            1.3.6.1.4.1.57264.1.1: 
                https://github.com/login/oauth
            CT Precertificate SCTs: 
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 08:60:92:F0:28:52:FF:68:45:D1:D1:6B:27:84:9C:45:
                                67:18:AC:16:3D:C3:38:D2:6D:E6:BC:22:06:36:6F:72
                    Timestamp : Aug 29 09:00:31.903 2022 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:45:02:21:00:FA:28:5C:16:36:93:36:E7:FD:87:D4:
                                14:CB:95:FC:56:4B:3D:13:D0:42:87:F6:97:C4:11:07:
                                4C:3E:D0:FA:F5:02:20:5C:A7:ED:B7:DC:4F:EB:B0:22:
                                04:9F:31:79:CC:B4:F1:91:9E:22:9C:36:9E:72:2E:DC:
                                EE:FE:3E:D5:FA:36:61
    Signature Algorithm: ecdsa-with-SHA384
         30:64:02:30:10:4d:ec:55:35:d6:e0:f5:72:7e:6d:25:ce:f5:
         60:4e:68:ab:48:b2:b6:b1:f7:66:c3:b9:0d:84:95:15:f5:bd:
         d2:31:1c:3b:9e:d3:fc:4c:82:38:e9:15:e9:1d:3a:d5:02:30:
         66:e8:14:e1:eb:5d:c6:78:fb:32:c0:6e:4a:0b:62:f6:57:44:
         1e:ff:4f:a3:b7:60:67:07:8f:37:ae:93:27:5a:bb:a1:89:2a:
         9c:01:5b:6e:40:ec:89:3d:52:49:e2:3c
-----BEGIN CERTIFICATE-----
MIICpzCCAi6gAwIBAgIUbYmKL+juRqTcWf9n4Bvq+1Fg3y0wCgYIKoZIzj0EAwMw
NzEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MR4wHAYDVQQDExVzaWdzdG9yZS1pbnRl
cm1lZGlhdGUwHhcNMjIwODI5MDkwMDMxWhcNMjIwODI5MDkxMDMxWjAAMFkwEwYH
KoZIzj0CAQYIKoZIzj0DAQcDQgAEMYkpOCblTHQDqOkjx3pDZ5BtHfFOFQBz+mry
xjlx4roliMM/TgzfUhRHkHOAQ2C/cGg4pHdUydboIg0fs+dR16OCAU0wggFJMA4G
A1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQU9myG
fNZ1+G3Is+/rrXh5L8CZnNswHwYDVR0jBBgwFoAU39Ppz1YkEZb5qNjpKFWixi4Y
ZD8wJwYDVR0RAQH/BB0wG4EZZGFuaWVsLmJldmVuaXVzQGdtYWlsLmNvbTAsBgor
BgEEAYO/MAEBBB5odHRwczovL2dpdGh1Yi5jb20vbG9naW4vb2F1dGgwgYoGCisG
AQQB1nkCBAIEfAR6AHgAdgAIYJLwKFL/aEXR0WsnhJxFZxisFj3DONJt5rwiBjZv
cgAAAYLo1LsfAAAEAwBHMEUCIQD6KFwWNpM25/2H1BTLlfxWSz0T0EKH9pfEEQdM
PtD69QIgXKftt9xP67AiBJ8xecy08ZGeIpw2nnIu3O7+PtX6NmEwCgYIKoZIzj0E
AwMDZwAwZAIwEE3sVTXW4PVyfm0lzvVgTmirSLK2sfdmw7kNhJUV9b3SMRw7ntP8
TII46RXpHTrVAjBm6BTh613GePsywG5KC2L2V0Qe/0+jt2BnB483rpMnWruhiSqc
AVtuQOyJPVJJ4jw=
-----END CERTIFICATE-----
```

Verify the artifact:
```console
$ sigstore verify npm-example-1.0.0.tgz signature signingcert.pem
Verified OK
```

Now, in the sigstore-js README.md there is a reference to the Rekor url
that looks like it was "supposed" to be in the sign commands output. I was not
able to find this and opened https://github.com/sigstore/sigstore-js/pull/68 to
address this.

But if we have the url we can get entry inforation from Rekor:
```console
$ curl --silent https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058 | jq --raw-output '.[].body' | base64 --decode | jq
```

_work in progress_

### Embedded signing and verification
Currently [hawkbit] is storing binary firmware along with metadata. We should be
able sign the binary using sigstore and storing the signature and certificate
in the json metadata. This is then later downloaded/sent to the device during
a firmware update. 
Questions:
* Can we verify the signatur of these downloaded firmware blobs without having
to reach/call out to Rekor?

* Can we store the sigstore root CA to verify the signature without making and
external call.

* A device would configure the DFU that is should perform verification. It is
the firmware application that is responsible for configuring DFU I think and
we should be able to hook this in there somehow.

### Get Fulcio root certificate
```console
$ curl -q https://fulcio.sigstore.dev/api/v1/rootCert | openssl x509 -text
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1531  100  1531    0     0   3147      0 --:--:-- --:--:-- --:--:--  3143
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            b9:d5:89:57:e7:53:46:eb:25:ab:26:46:41:eb:9f:f5:27:7d:a4
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: O = sigstore.dev, CN = sigstore
        Validity
            Not Before: Apr 13 20:06:15 2022 GMT
            Not After : Oct  5 13:56:58 2031 GMT
        Subject: O = sigstore.dev, CN = sigstore-intermediate
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    04:f1:15:52:ff:2b:07:f8:d3:af:b8:36:72:3c:86:
                    6d:8a:58:14:17:d3:65:6a:b6:29:01:df:47:3f:5b:
                    c1:04:7d:54:e4:25:7b:ec:b4:92:ee:cd:19:88:7e:
                    27:13:b1:ef:ee:9b:52:e8:bb:ef:47:f4:93:93:bf:
                    7c:2d:58:0c:cc:b9:49:e0:77:88:7c:5d:ed:1d:26:
                    9e:c4:b7:18:a5:20:12:af:59:12:d0:df:d1:80:12:
                    73:ff:d8:d6:0a:25:e7
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        X509v3 extensions:
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Extended Key Usage: 
                Code Signing
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Subject Key Identifier: 
                DF:D3:E9:CF:56:24:11:96:F9:A8:D8:E9:28:55:A2:C6:2E:18:64:3F
            X509v3 Authority Key Identifier: 
                keyid:58:C0:1E:5F:91:45:A5:66:A9:7A:CC:90:A1:93:22:D0:2A:C5:C5:FA

    Signature Algorithm: ecdsa-with-SHA384
         30:64:02:30:3c:2b:10:2b:80:d8:89:96:03:3c:86:83:8b:91:
         c5:2a:77:f1:5f:1e:80:49:25:66:11:17:ec:ca:76:01:89:7d:
         97:e9:22:51:9d:95:3c:e3:ff:43:65:d9:c5:be:fc:66:02:30:
         4e:b7:a4:29:06:57:38:27:fd:03:c6:f9:13:0a:aa:5c:96:fc:
         e2:2f:a0:42:08:f9:e3:76:52:01:dc:fb:b7:07:1b:0f:9b:28:
         14:63:b2:22:db:36:dd:09:d9:62:8a:8c
-----BEGIN CERTIFICATE-----
MIICGjCCAaGgAwIBAgIUALnViVfnU0brJasmRkHrn/UnfaQwCgYIKoZIzj0EAwMw
KjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y
MjA0MTMyMDA2MTVaFw0zMTEwMDUxMzU2NThaMDcxFTATBgNVBAoTDHNpZ3N0b3Jl
LmRldjEeMBwGA1UEAxMVc2lnc3RvcmUtaW50ZXJtZWRpYXRlMHYwEAYHKoZIzj0C
AQYFK4EEACIDYgAE8RVS/ysH+NOvuDZyPIZtilgUF9NlarYpAd9HP1vBBH1U5CV7
7LSS7s0ZiH4nE7Hv7ptS6LvvR/STk798LVgMzLlJ4HeIfF3tHSaexLcYpSASr1kS
0N/RgBJz/9jWCiXno3sweTAOBgNVHQ8BAf8EBAMCAQYwEwYDVR0lBAwwCgYIKwYB
BQUHAwMwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU39Ppz1YkEZb5qNjp
KFWixi4YZD8wHwYDVR0jBBgwFoAUWMAeX5FFpWapesyQoZMi0CrFxfowCgYIKoZI
zj0EAwMDZwAwZAIwPCsQK4DYiZYDPIaDi5HFKnfxXx6ASSVmERfsynYBiX2X6SJR
nZU84/9DZdnFvvxmAjBOt6QpBlc4J/0DxvkTCqpclvziL6BCCPnjdlIB3Pu3BxsP
mygUY7Ii2zbdCdliiow=
-----END CERTIFICATE-----

```

[hawkbit]: https://www.eclipse.org/hawkbit/


### Offline verification
From https://www.chainguard.dev/unchained/busting-5-sigstore-myths:
```
Another common use case is that organizations need to run systems in air-gapped
environments with no outside network access. That means it’s not possible to
look up a signature in the transparency log, Rekor, right? Wrong! We use what’s
called “stapled inclusion proofs” by default, meaning you can verify an object
is present in the transparency log without needing to contact the transparency
log! The signer is responsible for gathering this evidence from the log and
presenting it alongside the artifact and signature. We store this in an OCI
image automatically, but you can treat it like a normal file and copy it around
for verification as well.
```
So I think this means that we should be able to add this "stapled inclusion
proofs" to storage which I think has support for additional metadata, either
an OCI repository or as [ORAS](https://oras.land/) thingy.


So lets first try signing a binary blob.
First we generate a keypair:
```console
$ cosign generate-key-pair
Enter password for private key: 
Enter password for private key again: 
Private key written to cosign.key
Public key written to cosign.pub
```
```console
$ echo "firmware..." > firmware.bin
```
```console
$ cosign sign-blob --key cosign.key firmware.bin 
Using payload from: firmware.bin
Enter password for private key: 
MEUCIQC6bGdQq+Y8Cudg7QCQbK8mMMBYLQxtIXqxfx9axNQTgQIgImy4OcK9ERn2Mi6NNcfi0UqS7aO3ei7+pfodI37iz80=
```
The output above is the base64-encoded signature.


### Bundle
Sigstore/Cosign can create a `bundle`, which contains all the information
required for stapled inclusion proofs, and this can be saved somewhere.

For example:
```console
COSIGN_EXPERIMENTAL=1 cosign sign-blob --bundle=artifact.bundle artifact.tx
```

The file `artifact.bundle` is file in json format that looks like this:
```console
{
  "SignedEntryTimestamp": "MEUCIQDHiGUesxPpn+qRONLmKlNIVPhl9gBMnwNeIQmRkRmZVQIgRxPpuYQDZR/8lYKcEfiQn5b+7VDoJIC72ZWHO9ZCp1A=",
  "Payload": {
    "body": "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJzcGVjIjp7ImRhdGEiOnsiaGFzaCI6eyJhbGdvcml0aG0iOiJzaGEyNTYiLCJ2YWx1ZSI6ImE0NDkyYjBlYWJkZDIzMTJmMDYzMjkwYWJkNzk3ZDlkNzFhM2FiMjhiZDY1YTJjMTg5YjBkZjBkMzliOGMzYjkifX0sInNpZ25hdHVyZSI6eyJjb250ZW50IjoiTUVRQ0lDTmRYeTNiWHAxRE1PTDZOUGZYMzVnSjI3YnpsZHdTdkNBTnd5ZE9RVWlqQWlCQWg5WlJwQ3AzYlg5eE9UbEhTR2w0cFVGd0ZtUFJJWGZpY09pRTBHM1Vzdz09IiwiZm9ybWF0IjoieDUwOSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2sxSlNVTmxla05EUVdkRFowRjNTVUpCWjBsVVZISk9aa013YkZSSmRWSXZWR0UyWm14MWFtdFFOWHBaTDFSQlMwSm5aM0ZvYTJwUFVGRlJSRUY2UVhFS1RWSlZkMFYzV1VSV1VWRkxSWGQ0ZW1GWFpIcGtSemw1V2xNMWExcFlXWGhGVkVGUVFtZE9Wa0pCVFZSRFNFNXdXak5PTUdJelNteE5RalJZUkZSSmVBcE5SRmw1VFdwSmVFMUVaM2RPUm05WVJGUkplRTFFV1hsTmFrbDRUV3BuZDAweGIzZEJSRUphVFVKTlIwSjVjVWRUVFRRNVFXZEZSME5EY1VkVFRUUTVDa0YzUlVoQk1FbEJRazFGV1M4ck4yRktjRmRLVFhjNWVrTmljMDFrT0hOQlRUTmxSbk5OTjBSbFpFZGlXRzlNUjJ4YUwyZHBNR2h5WTBaU1NWVTRiM2NLUzBKeU1ISkVTRE5QVkZaSWJVdFVZMkV2SzIweGQxQjNTVzlZTTFGUVYycG5aMFYwVFVsSlFrdFVRVTlDWjA1V1NGRTRRa0ZtT0VWQ1FVMURRalJCZHdwRmQxbEVWbEl3YkVKQmQzZERaMWxKUzNkWlFrSlJWVWhCZDAxM1JFRlpSRlpTTUZSQlVVZ3ZRa0ZKZDBGRVFXUkNaMDVXU0ZFMFJVWm5VVlZ5WVRoTENuSnJaMjAzVGtsNFRrNXBVMkpZVG00eFdFVkxhRzFyZDBoM1dVUldVakJxUWtKbmQwWnZRVlY1VFZWa1FVVkhZVXBEYTNsVlUxUnlSR0UxU3pkVmIwY0tNQ3QzZDJkWk1FZERRM05IUVZGVlJrSjNSVUpDU1VkQlRVZzBkMlpCV1VsTGQxbENRbEZWU0UxQlMwZGpSMmd3WkVoQk5reDVPWGRqYld3eVdWaFNiQXBaTWtWMFdUSTVkV1JIVm5Wa1F6QXlUVVJPYlZwVVpHeE9lVEIzVFVSQmQweFVTWGxOYW1OMFdXMVpNMDVUTVcxT1Ixa3hXbFJuZDFwRVNUVk9WRkYxQ21NelVuWmpiVVp1V2xNMWJtSXlPVzVpUjFab1kwZHNla3h0VG5aaVV6bHFXVlJOTWxsVVJteFBWRmw1VGtSS2FVOVhXbXBaYWtVd1RtazVhbGxUTldvS1kyNVJkMHBCV1VSV1VqQlNRVkZJTDBKQ2IzZEhTVVZYWTBoS2NHVlhSak5aVjFKdlpESkdRVm95T1haYU1uaHNURzFPZG1KVVFVdENaMmR4YUd0cVR3cFFVVkZFUVhkT2NFRkVRbTFCYWtWQk1UQlVSR015Wm1oUFZrRlVNWFJzZFM4MmMzWnhSbEZ1YkRaWU9YZGhNbXRUU2t0RGJqUkZZbFJFYTNwYVJYb3lDblppUWtwb2FFZ3ZjbWRXUjFKMU5tWkJha1ZCYkhsb05uUmhZelJZVFRaS2IzVlZlRWtyTjFnelFtUTFXVXR5WlRGS1dFOWhia0ZaYW1adldHNTVUSFFLZDNCSVFWb3paVzFhY0VWa00yeHFTVEF3Vm04S0xTMHRMUzFGVGtRZ1EwVlNWRWxHU1VOQlZFVXRMUzB0TFFvPSJ9fX0sImtpbmQiOiJyZWtvcmQifQ==",
    "integratedTime": 1624396085,
    "logIndex": 5179,
    "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d"
  }
}
```
`SignedEntryTimestamp` is a signature of the `logIndex`, `body`, and
the `integratedTime` time fields created by Rekor.

The signature can be be retrieved from Rekor using the following command:
```console
$ curl --silent https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058 | jq '.[].verification.signedEntryTimestamp'
"MEQCIAD7UUGDjQPvdOP28REv7Lq/ZGQn3j5u4HVdz6IMDBEHAiAlpXP5BD0Hx5CRkcqcfbRJRIjdpschUGf0XcOC6xuuyw=="
```

The payload of a `Bundle` contains a base64 encoded string:
```console
$ cat artifact.bundle | jq -r '.rekorBundle.Payload.body' | base64 -d - | jq
```
Which will produce:
```json
{
  "apiVersion": "0.0.1",
  "kind": "hashedrekord",
  "spec": {
    "data": {
      "hash": {
        "algorithm": "sha256",
        "value": "4bc453b53cb3d914b45f4b250294236adba2c0e09ff6f03793949e7e39fd4cc1"
      }
    },
    "signature": {
      "content": "MEQCIGp1XZP5zaImosrBhDPCdXn3f8xI9FHGLsGVx6UeRPCgAiAt5GrsdQhOKnZcA3EWecvgJSHzCIjWifFBQkD7Hdsymg==",
      "publicKey": {
        "content": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNxRENDQWkrZ0F3SUJBZ0lVVFBXVGZPLzFOUmFTRmRlY2FBUS9wQkRHSnA4d0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJeE1USTFNRGN6TnpFeVdoY05Nakl4TVRJMU1EYzBOekV5V2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVKUVE0Vy81WFA5bTRZYldSQlF0SEdXd245dVVoYWUzOFVwY0oKcEVNM0RPczR6VzRNSXJNZlc0V1FEMGZ3cDhQVVVSRFh2UTM5NHBvcWdHRW1Ta3J1THFPQ0FVNHdnZ0ZLTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVVvM0tuCmpKUVowWGZpZ2JENWIwT1ZOTjB4cVNvd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZc0dDaXNHCkFRUUIxbmtDQkFJRWZRUjdBSGtBZHdEZFBUQnF4c2NSTW1NWkhoeVpaemNDb2twZXVONDhyZitIaW5LQUx5bnUKamdBQUFZU3R1Qkh5QUFBRUF3QklNRVlDSVFETTVZU1EvR0w2S0k1UjlPZGNuL3BTaytxVkQ2YnNMODMrRXA5UgoyaFdUYXdJaEFLMWppMWxaNTZEc2Z1TGZYN2JCQzluYlIzRWx4YWxCaHYxelFYTVU3dGx3TUFvR0NDcUdTTTQ5CkJBTURBMmNBTUdRQ01CSzh0c2dIZWd1aCtZaGVsM1BpakhRbHlKMVE1SzY0cDB4cURkbzdXNGZ4Zm9BUzl4clAKczJQS1FjZG9EOWJYd2dJd1g2ekxqeWJaa05IUDV4dEJwN3ZLMkZZZVp0ME9XTFJsVWxsY1VETDNULzdKUWZ3YwpHU3E2dlZCTndKMDB3OUhSCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
      }
    }
  }
}
```
And we can check that this matches the record in Rekor using this command:
```console
$ curl --silent https://rekor.sigstore.dev/api/v1/log/entries?logIndex=4874058 | jq -r '."24296fb24b8ad77addfc1725ba17e24520eb3c7899bb4467ffd22396be7aae0366bd1f1574384262".body' | base64 -d - | jq
{
  "apiVersion": "0.0.1",
  "kind": "hashedrekord",
  "spec": {
    "data": {
      "hash": {
        "algorithm": "sha256",
        "value": "4f2fb5c9d049ebad8d3d25f55ffdf49b290f7f84f56b89fe3d6663b48b856ad1"
      }
    },
    "signature": {
      "content": "MEUCIQC81kdqAOdcEEuGA8CIk9ToTJhX8P42N9t59t2zgLfQTQIgfhILgdc5bFmBxayTkabRhOyeUY1fkr0x4GqBTVlixx8=",
      "publicKey": {
        "content": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNxVENDQWk2Z0F3SUJBZ0lVQXkvM1haU0xsWmwrUExXZ05DU0VZaXV2Nyswd0NnWUlLb1pJemowRUF3TXcKTnpFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUjR3SEFZRFZRUURFeFZ6YVdkemRHOXlaUzFwYm5SbApjbTFsWkdsaGRHVXdIaGNOTWpJeE1ERXhNRGN5TURBd1doY05Nakl4TURFeE1EY3pNREF3V2pBQU1Ga3dFd1lICktvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVzaEVyNW9LL1hTSkoyaFg4am1ZVE9mYW1oQjM4aDRISEx0R2QKQkE1L3Z1ZUxsVENWTUpnRm1FMXZ3MUJudWljS3R4RjNGaWVjT1JhS3M3TUlmT1RDQ3FPQ0FVMHdnZ0ZKTUE0RwpBMVVkRHdFQi93UUVBd0lIZ0RBVEJnTlZIU1VFRERBS0JnZ3JCZ0VGQlFjREF6QWRCZ05WSFE0RUZnUVVvWjFGClM4Sk1mS3d4M2k4bE9mWW1Uc05GVkJvd0h3WURWUjBqQkJnd0ZvQVUzOVBwejFZa0VaYjVxTmpwS0ZXaXhpNFkKWkQ4d0p3WURWUjBSQVFIL0JCMHdHNEVaWkdGdWFXVnNMbUpsZG1WdWFYVnpRR2R0WVdsc0xtTnZiVEFzQmdvcgpCZ0VFQVlPL01BRUJCQjVvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2Ykc5bmFXNHZiMkYxZEdnd2dZb0dDaXNHCkFRUUIxbmtDQkFJRWZBUjZBSGdBZGdBSVlKTHdLRkwvYUVYUjBXc25oSnhGWnhpc0ZqM0RPTkp0NXJ3aUJqWnYKY2dBQUFZUEY2aWdSQUFBRUF3QkhNRVVDSVFDK1FCR2swdkRiMjhZcVgzSElXWTBlSElPYW56eFI3Zk9GQmorYQpKQnFxSUFJZ2ZkV21MZGhqYWJuYnZmWmpmcTBlQy95N29NYmxkRzdYZEdSamlwVGd2YTB3Q2dZSUtvWkl6ajBFCkF3TURhUUF3WmdJeEFPb3lXY1J6cU9KZVZJWmx2Q096M1BTb3ZFVnAzZXZ0UU1iZWxpMFFRc1FxNWt2OUFJZUYKYkxOTmdmazk2U1BwRXdJeEFLcTVuQmFOZmpEQnJIOXpQUTdzK1JadkJoMUR1d1RtV1NNdmZZNkYyZnhZallZOApIdFc4L2c3bFhHUTBKdElLUGc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlDR2pDQ0FhR2dBd0lCQWdJVUFMblZpVmZuVTBickphc21Sa0hybi9VbmZhUXdDZ1lJS29aSXpqMEVBd013CktqRVZNQk1HQTFVRUNoTU1jMmxuYzNSdmNtVXVaR1YyTVJFd0R3WURWUVFERXdoemFXZHpkRzl5WlRBZUZ3MHkKTWpBME1UTXlNREEyTVRWYUZ3MHpNVEV3TURVeE16VTJOVGhhTURjeEZUQVRCZ05WQkFvVERITnBaM04wYjNKbApMbVJsZGpFZU1Cd0dBMVVFQXhNVmMybG5jM1J2Y21VdGFXNTBaWEp0WldScFlYUmxNSFl3RUFZSEtvWkl6ajBDCkFRWUZLNEVFQUNJRFlnQUU4UlZTL3lzSCtOT3Z1RFp5UEladGlsZ1VGOU5sYXJZcEFkOUhQMXZCQkgxVTVDVjcKN0xTUzdzMFppSDRuRTdIdjdwdFM2THZ2Ui9TVGs3OThMVmdNekxsSjRIZUlmRjN0SFNhZXhMY1lwU0FTcjFrUwowTi9SZ0JKei85aldDaVhubzNzd2VUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0V3WURWUjBsQkF3d0NnWUlLd1lCCkJRVUhBd013RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBZEJnTlZIUTRFRmdRVTM5UHB6MVlrRVpiNXFOanAKS0ZXaXhpNFlaRDh3SHdZRFZSMGpCQmd3Rm9BVVdNQWVYNUZGcFdhcGVzeVFvWk1pMENyRnhmb3dDZ1lJS29aSQp6ajBFQXdNRFp3QXdaQUl3UENzUUs0RFlpWllEUElhRGk1SEZLbmZ4WHg2QVNTVm1FUmZzeW5ZQmlYMlg2U0pSCm5aVTg0LzlEWmRuRnZ2eG1BakJPdDZRcEJsYzRKLzBEeHZrVENxcGNsdnppTDZCQ0NQbmpkbElCM1B1M0J4c1AKbXlnVVk3SWkyemJkQ2RsaWlvdz0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQotLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJQjl6Q0NBWHlnQXdJQkFnSVVBTFpOQVBGZHhIUHdqZURsb0R3eVlDaEFPLzR3Q2dZSUtvWkl6ajBFQXdNdwpLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQWVGdzB5Ck1URXdNRGN4TXpVMk5UbGFGdzB6TVRFd01EVXhNelUyTlRoYU1Db3hGVEFUQmdOVkJBb1RESE5wWjNOMGIzSmwKTG1SbGRqRVJNQThHQTFVRUF4TUljMmxuYzNSdmNtVXdkakFRQmdjcWhrak9QUUlCQmdVcmdRUUFJZ05pQUFUNwpYZUZUNHJiM1BRR3dTNElhanRMazMvT2xucGdhbmdhQmNsWXBzWUJyNWkrNHluQjA3Y2ViM0xQME9JT1pkeGV4Clg2OWM1aVZ1eUpSUStIejA1eWkrVUYzdUJXQWxIcGlTNXNoMCtIMkdIRTdTWHJrMUVDNW0xVHIxOUw5Z2c5MmoKWXpCaE1BNEdBMVVkRHdFQi93UUVBd0lCQmpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJSWQp3QjVma1VXbFpxbDZ6SkNoa3lMUUtzWEYrakFmQmdOVkhTTUVHREFXZ0JSWXdCNWZrVVdsWnFsNnpKQ2hreUxRCktzWEYrakFLQmdncWhrak9QUVFEQXdOcEFEQm1BakVBajFuSGVYWnArMTNOV0JOYStFRHNEUDhHMVdXZzF0Q00KV1AvV0hQcXBhVm8wamhzd2VORlpnU3MwZUU3d1lJNHFBakVBMldCOW90OThzSWtvRjN2WllkZDMvVnRXQjViOQpUTk1lYTdJeC9zdEo1VGZjTExlQUJMRTRCTkpPc1E0dm5CSEoKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo="
      }
    }
  }
}
```
Now, when we want to verify an artifact using a bundle we provi
```
$ cosign verify-blob --bundle=artifact.bundle artifact.txt
tlog entry verified offline
Verified OK
```
