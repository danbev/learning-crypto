## embedded-tls in-toto task
This document contains notes about adding [in-toto](https://in-toto.io/) to
[embedded-tls](https://github.com/drogue-iot/embedded-tls).

The working branch can be found here:
[sscs](https://github.com/danbev/embedded-tls/tree/sscs).

### Goals
One goal of this task is to gain a better understanding of what is involved in
adding code-signing and code attestation to a source distributed open source
project. 

A second goal is to understand how verification of the attestations can done for
source distributed projects.

For open source software dependency projects we are making a few assumptions
which might not hold for all projects but for a good portion of them. We are
assuming they are rather small and won't require multple physical funcionaries.
And since these are source distributed software project they don't contain any
packaging steps (like tar, jar, rpm, etc).

### Creating the software supply chain layout file
The [layout] is a file in json format that defines what [steps] are required to
be performed by the software maintainers. This could include tasks like cloning
the repository, updating the version, and running tests. These steps produce
in-toto link metadata files which are later used by the verification process.

The layout also contains [inspect] operations that are to be performed by the
verification process. This process is run by the end user.

#### Generating the steps
This are currently performed by a script named [create-steps] and currently
these are just made up to have something to work with to get familiar with
things.
Example of running create-steps.sh:
```console
$ ./create-steps.sh 
1) Generating keypair named sscs-tool
2) Cloning https://github.com/drogue-iot/embedded-tls.git
3) Create new branch named version_update_branch
Switched to a new branch 'version_update_branch'
4) Update Cargo.toml version using cargo-bump
[version_update_branch a246040] Bumped version
 1 file changed, 1 insertion(+), 1 deletion(-)
5) Run tests
    Finished test [unoptimized + debuginfo] target(s) in 0.08s
     Running unittests src/lib.rs (embedded-tls/target/debug/deps/embedded_tls-d2b3389582d85d7d)

running 2 tests
test buffer::test::encode ... ok
test buffer::test::offset_calc ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/client_test.rs (embedded-tls/target/debug/deps/client_test-0661a530bde32595)

running 2 tests
test test_ping ... ok
test test_blocking_ping ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.06s

     Running tests/tlsserver.rs (embedded-tls/target/debug/deps/tlsserver-e3bb721faf984043)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests embedded-tls

running 1 test
test src/lib.rs - (line 29) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.50s

6) Copy artifacts
Copying the following link files to artifacts directory:
clone_project.c811a5bf.link
create_branch.c811a5bf.link
run_tests.c811a5bf.link
update-version.c811a5bf.link
```

#### Generating the layout
The layout is generated by the [create-layout] python script.
```console
$ ./create-layout.py 
Created artifacts/root.layout file
```

### Verifying
So at this point we have artifacts directory contains the link files, the
public key (for the private key that was used to sign the link file sections),
and the root.layout file. These files are required for verification:
```console
$ in-toto-verify -v --layout root.layout --layout-key sscs-tool.pub
Loading layout...
Loading layout key(s)...
Verifying layout signatures...
Verifying layout expiration...
Reading link metadata files...
Verifying link metadata signatures...
Verifying sublayouts...
Verifying alignment of reported commands...
Verifying command alignment for 'clone_project.3b7d362f.link'...
Verifying command alignment for 'update-version.3b7d362f.link'...
Verifying threshold constraints...
Skipping threshold verification for step 'clone_project' with threshold '1'...
Skipping threshold verification for step 'update-version' with threshold '1'...
Verifying Step rules...
Verifying material rules for 'clone_project'...
Verifying product rules for 'clone_project'...
Verifying 'CREATE embedded-tls'...
Verifying 'ALLOW embedded-tls/*'...
Verifying material rules for 'update-version'...
Verifying 'MATCH embedded-tls/* WITH PRODUCTS FROM clone_project'...
Verifying 'ALLOW Cargo.toml'...
Verifying 'DISALLOW *'...
Verifying product rules for 'update-version'...
Verifying 'MODIFY Cargo.toml'...
Verifying 'ALLOW Cargo.lock'...
Verifying 'ALLOW sscs-tool.pub'...
Verifying 'ALLOW sscs-tool'...
Verifying 'ALLOW root.layout'...
Verifying 'DISALLOW *'...
Executing Inspection commands...
Executing command for inspection 'cargo-fetch'...
Running 'cargo-fetch'...
Recording materials '.'...
Running command 'git clone https://github.com/drogue-iot/embedded-tls.git'...
Recording products '.'...
Creating link metadata...
Verifying Inspection rules...
Verifying material rules for 'cargo-fetch'...
Verifying 'MATCH embedded-tls/* WITH PRODUCTS FROM clone_project'...
Verifying 'ALLOW embedded-tls/target'...
Verifying 'ALLOW sscs-tool.pub'...
Verifying 'ALLOW sscs-tool'...
Verifying 'ALLOW root.layout'...
Verifying 'DISALLOW *'...
Verifying product rules for 'cargo-fetch'...
Verifying 'MATCH embedded-tls/Cargo.toml WITH PRODUCTS FROM update-version'...
Verifying 'MATCH * WITH PRODUCTS FROM clone_project'...
Verifying 'ALLOW embedded-tls/target'...
Verifying 'ALLOW sscs-tool.pub'...
Verifying 'ALLOW sscs-tool'...
Verifying 'ALLOW root-layout'...
The software product passed all verification.
```
_Disclaimer_: I'm not sure I've gotten the layout correct and I'm still very
much investigating and learning at this point.

### Suggestion
Could we perhaps produce a tool that does something simlar to what the above
scripts do for Rust projects.

For example, it could be installed as a Cargo custom command:
```console
$ cargo install trustification
```
Then to generate default steps for a project, perhaps only clone and run tests:
```console
$ cargo trustification gen-steps
```
Hopefully this would be able to use a "keyless" approach similar to sigstore's
cosign tool which used OIDC. For example, is should be possible to get the
keypair using [sigstore-rs](https://github.com/danbev/sigstore-rs/blob/fulcio_get_keypair_example/examples/fulcio/cert/main.rs).

And then to generate the root.layout:
```console
$ cargo trustification gen-layout
```
The idea would be that these tasks be run as part of, or before, the release
process. By default the link files and root.layout would be generated in a
directory named `sscs` or something like that and could be configurable. These
files would then be checked in.

A user of this project would include this project as a dependency in Cargo.toml
and the verification would be performed on the project that Cargo fetched. 
The user could run this tool manually or call it as part of a release process
to verify that there are no vulnerabilities in the project.
```
$ cargo trustification verify embedded-tls
```
The idea here is that this verify operation would use the link files, layout
and public key from the repository that Cargo fetches. So the in-toto-verfify
command takes a `--layout`, a `--layout-keys`, and a `--link-dir` option which
perhaps could be pointed to the repository that cargo checked out:
```console
$ in-toto-verify -v --layout $CARGO_HOME/git/checkouts/ebedded-tls-<sha>/sscs/artifacts/root.layout \
   --layout-key $CARGO_HOME/git/checkouts/ebedded-tls-<sha>/sscs/artifacts/sscs-tool.pub \
   --link-dir $CARGO_HOME/git/checkouts/ebedded-tls-<sha>/sscs/artifacts
```

This would hopefully work, but we do have a manual step which the OIDC step part
which generates the shortlived keypair. For the majority of projects building/
releasing is an automated process. Having a manual step is not going to work in
these cases and if we want all projects to be secured at some point, the effort
of adding such security should be as small as possible. And including it in a
normal build server should be a one time configuration/step or users will not do
 it.(similar to many did not bother with certificates before Lets Encrypt but
since it was so simple there was not any reason not do add it).

Sigstore's Code Signing CA can, in addition to OIDC, issue tokens based on
[SPIFFI](./spiffe.md) so instead of binding public keys to email addresses which
is what OIDC does, in this case we are binding to SPIFFE Verified Identity
Document (SVID) to public keys.

We would upload our root trust domain certificate and a SPIFFE ID, something
like spiffe://sscs.redhat.com/build. 
In this case I think the build server would request a x509 SVID from the SPIRE
server, it then creates keypair and generates a certificate signing request and
includes that SVID and the public key (in the OIDC flow this would have been the
verified email address and the public key) which is sent to Fulcio. 


### Questions
#### When do we want to generate the in-toto artifacts?  
This will probably only be done at the time of a new release. So for each
release the tool is run to verify that the sources, and run the tests, and sign
the in-toto link files. 

What I'm currently trying to figure out is that for source distributed projects
there is no package/archive release where we can stick the .link files and the
layout file which are needed for verification. Perhaps we can store these in the
source repository which makes them available when fetching them with Cargo or
any other tool. So the generation of link metadata would be a step called as
part of the release process.

#### What about embedded-tls's dependencies
The above suggestion would take care of securing embedded-tls itself which is
a good thing, but embedded-tls also has dependencies of it's own. If one of
those dependencies are attacked in some way embedded-tls is also vulnerable as
are projects that have embedded-tls as a dependency.
If we could make this above suggested tool general enough and easy to apply
perhaps we can get those projects to start using this, by opening pull requests
for the dependencies that we and our customer use. This feels kind of hopeless
as there are not many projects that have this yet but perhaps that is also an
oppertunity for us. And I think we will find that there are many project that
are common to multiple projects, like log, serde, rand, mio, tokio etc.


_wip_

[layout]: https://github.com/in-toto/docs/blob/master/in-toto-spec.md#43-file-formats-layout
[steps]: https://github.com/in-toto/docs/blob/master/in-toto-spec.md#431-steps
[inspect]: https://github.com/in-toto/docs/blob/master/in-toto-spec.md#432-inspections
[create-steps]: https://github.com/danbev/embedded-tls/blob/sscs/sscs/create-steps.sh
[create-layout]: https://github.com/danbev/embedded-tls/blob/sscs/sscs/create-layout.py

